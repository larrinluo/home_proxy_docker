# 详细方案设计文档

## 文档说明

本文档是基于`docs/需求.md`和`docs/UI前端设计.md`生成的详细技术方案设计文档，用于指导项目的具体实现。

**重要说明**：本文档中关于前端UI设计的详细内容直接引用`docs/UI前端设计.md`，不再重复展开。前端架构设计章节仅包含技术实现相关的架构设计，UI设计规范请参考`docs/UI前端设计.md`。

---

## 目录

- [一、文档概述](#一文档概述)
- [二、系统架构设计](#二系统架构设计)
- [三、技术选型](#三技术选型)
- [四、数据库设计](#四数据库设计)
- [五、后端API设计](#五后端api设计)
- [六、前端架构设计](#六前端架构设计)
- [七、代理服务实现](#七代理服务实现)
- [八、PAC配置生成](#八pac配置生成)
- [九、用户认证与授权](#九用户认证与授权)
- [十、Docker构建方案](#十docker构建方案)
- [十一、部署方案](#十一部署方案)
- [十二、开发阶段划分](#十二开发阶段划分)
- [十三、附录](#十三附录)

---

## 一、文档概述

### 1.1 项目背景

本项目旨在开发一个"一键构建代理服务器docker"工具，为用户提供便捷的Socks代理服务搭建方案。项目核心功能包括：

- **代理服务管理**：用户可以通过Web界面创建、删除、启动、停止基于SSH跳板服务的Socks代理服务
- **Host配置管理**：用户可以配置哪些域名通过哪个代理服务访问，支持灵活的代理规则配置
- **PAC配置生成**：系统自动根据Host配置生成PAC代理配置文件，供客户端使用
- **用户管理**：支持用户注册、登录、个人信息管理等功能
- **系统配置**：支持系统全局参数配置，如账号注册开关等

项目采用Docker容器化部署，支持x86和arm64架构，所有服务（nginx、后端服务、代理服务）都部署在同一个容器中，便于在小型Linux设备上部署。

### 1.2 文档目的

本文档作为项目的详细技术方案设计文档，主要目的包括：

1. **指导开发实现**：为开发团队提供详细的技术实现方案，包括架构设计、数据库设计、API设计等
2. **规范开发流程**：明确开发阶段划分和开发计划，确保项目按计划推进
3. **技术选型说明**：详细说明各项技术选型的理由和使用方式
4. **部署指导**：提供Docker构建和部署的详细方案，确保项目能够顺利部署运行

本文档面向开发人员、架构师和运维人员，是项目实施的重要参考文档。

### 1.3 文档结构说明

本文档共分为十三个主要章节：

- **第一章 文档概述**：介绍项目背景、文档目的和结构说明
- **第二章 系统架构设计**：描述整体系统架构、模块划分和数据流设计
- **第三章 技术选型**：详细说明后端、前端、数据库等各项技术选型
- **第四章 数据库设计**：设计数据库表结构、关系和索引
- **第五章 后端API设计**：设计RESTful API接口规范
- **第六章 前端架构设计**：设计前端技术架构和项目结构（UI设计规范引用UI前端设计.md）
- **第七章 代理服务实现**：详细说明SSH代理服务的实现方案
- **第八章 PAC配置生成**：说明PAC配置文件的生成逻辑和格式
- **第九章 用户认证与授权**：设计用户认证和权限管理方案
- **第十章 Docker构建方案**：设计Docker镜像构建方案
- **第十一章 部署方案**：设计容器部署和配置方案
- **第十二章 开发阶段划分**：划分开发阶段和制定开发计划
- **第十三章 附录**：提供API清单、数据库表结构清单等参考资料

### 1.4 UI前端设计引用说明

**重要说明**：本文档中关于前端UI设计的详细内容直接引用`docs/UI前端设计.md`文档，不再重复展开。

`docs/UI前端设计.md`文档包含了完整的前端UI设计规范，包括：

- 整体布局设计
- 各个组件的详细设计规范
- 交互细节设计
- 响应式设计
- UI风格规范
- 组件清单

本文档的"第六章 前端架构设计"章节仅包含前端技术架构和实现相关的设计，如项目结构、状态管理、路由设计等。关于UI组件的具体设计、样式规范、交互细节等内容，请直接参考`docs/UI前端设计.md`。

在开发过程中，前端开发人员应同时参考本文档的技术架构设计和`docs/UI前端设计.md`的UI设计规范，确保实现既符合技术架构要求，又符合UI设计规范。

---

## 二、系统架构设计

### 2.1 整体架构

系统采用单体容器架构，所有服务部署在同一个Docker容器中，包括：

```
┌─────────────────────────────────────────────────┐
│           Docker Container                      │
│  ┌──────────────────────────────────────────┐  │
│  │         Nginx (反向代理)                   │  │
│  │  - 静态文件服务 (前端)                     │  │
│  │  - API反向代理 (后端)                      │  │
│  │  - PAC文件服务                             │  │
│  └──────────────┬───────────────────────────┘  │
│                 │                                │
│  ┌──────────────▼───────────────────────────┐  │
│  │      Node.js 后端服务                      │  │
│  │  - RESTful API                            │  │
│  │  - 用户认证与授权                          │  │
│  │  - 代理服务管理                           │  │
│  │  - Host配置管理                           │  │
│  │  - PAC配置生成                            │  │
│  │  - 数据库操作                             │  │
│  └──────────────┬───────────────────────────┘  │
│                 │                                │
│  ┌──────────────▼───────────────────────────┐  │
│  │      SQLite 数据库                        │  │
│  │  - 用户数据                               │  │
│  │  - 代理服务配置                           │  │
│  │  - Host配置                               │  │
│  │  - 系统配置                               │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │      代理服务进程管理                      │  │
│  │  - autossh进程管理                        │  │
│  │  - SSH密钥管理                            │  │
│  │  - 端口管理                               │  │
│  │  - 状态监控                               │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

**架构特点**：

1. **单容器部署**：所有服务（nginx、后端、数据库、代理服务）都在同一个容器中，简化部署和管理
2. **前后端分离**：前端通过nginx提供静态文件服务，后端提供RESTful API
3. **轻量级数据库**：使用SQLite数据库，无需单独的数据库服务，适合小型部署
4. **进程管理**：后端服务负责管理autossh进程，实现代理服务的生命周期管理

### 2.2 模块划分

系统主要分为以下模块：

#### 2.2.1 前端模块（Front-end）

- **位置**：`server/front-end`
- **技术栈**：Vue 3 + Element Plus + Vite
- **主要功能**：
  - 用户界面展示
  - 用户交互处理
  - API调用
  - 状态管理
- **构建产物**：静态文件（HTML、CSS、JS），由nginx提供服务

#### 2.2.2 后端模块（Back-end）

- **位置**：`server/back-end`
- **技术栈**：Node.js + Express（或类似框架）
- **主要功能模块**：
  - **认证模块**：用户注册、登录、会话管理
  - **用户管理模块**：用户信息管理、密码修改
  - **代理服务管理模块**：代理服务的创建、删除、启动、停止
  - **Host配置管理模块**：Host配置的创建、编辑、删除
  - **PAC配置生成模块**：根据Host配置生成PAC文件
  - **系统配置模块**：系统全局参数管理
  - **代理服务进程管理模块**：autossh进程的启动、停止、监控

#### 2.2.3 数据库模块

- **数据库类型**：SQLite
- **存储位置**：容器内持久化存储（通过volume挂载）
- **主要数据表**：
  - users：用户信息
  - proxy_services：代理服务配置
  - host_configs：Host配置
  - system_configs：系统配置

#### 2.2.4 代理服务模块

- **技术实现**：autossh + SSH -D
- **管理方式**：由后端服务通过进程管理
- **主要功能**：
  - SSH密钥生成和管理
  - SSH隧道建立和维护
  - 代理端口监听
  - 服务状态监控

#### 2.2.5 Web服务器模块（Nginx）

- **主要功能**：
  - 前端静态文件服务
  - 后端API反向代理
  - PAC文件服务
  - 请求路由和负载均衡（单实例场景下主要用于路由）

### 2.3 数据流设计

#### 2.3.1 用户操作流程

```
用户浏览器
    │
    │ HTTP请求
    ▼
Nginx (反向代理)
    │
    ├─── 静态文件请求 ───► 前端静态文件 (HTML/CSS/JS)
    │
    └─── API请求 ───► Node.js 后端服务
                            │
                            ├─── 数据库操作 ───► SQLite 数据库
                            │
                            └─── 代理服务操作 ───► autossh进程管理
```

#### 2.3.2 代理服务创建流程

```
1. 用户在前端填写代理服务配置
   │
   ▼
2. 前端调用后端API创建代理服务
   │
   ▼
3. 后端生成SSH密钥对
   │
   ▼
4. 后端使用密码连接跳板服务器，推送公钥
   │
   ▼
5. 后端创建代理服务记录（数据库）
   │
   ▼
6. 后端启动autossh进程
   │
   ▼
7. 后端创建关联的Host配置（数据库）
   │
   ▼
8. 返回创建结果给前端
```

#### 2.3.3 PAC配置生成流程

```
1. 用户修改Host配置
   │
   ▼
2. 前端调用后端API更新Host配置
   │
   ▼
3. 后端更新数据库中的Host配置
   │
   ▼
4. 后端查询所有Host配置和关联的代理服务
   │
   ▼
5. 后端生成PAC配置JSON
   │
   ▼
6. 后端保存PAC配置（文件或数据库）
   │
   ▼
7. 前端请求PAC文件时，nginx直接提供或通过后端API提供
```

### 2.4 服务间通信

#### 2.4.1 前端与后端通信

- **通信协议**：HTTP/HTTPS
- **数据格式**：JSON
- **API风格**：RESTful API
- **认证方式**：Session或JWT Token

#### 2.4.2 后端与数据库通信

- **数据库类型**：SQLite
- **连接方式**：文件数据库连接
- **ORM/查询方式**：使用Node.js的SQLite库（如sqlite3）

#### 2.4.3 后端与代理服务通信

- **管理方式**：进程管理
- **通信方式**：
  - 启动/停止：通过进程spawn/kill
  - 状态查询：通过进程状态检查或端口监听检查
  - 日志输出：通过进程stdout/stderr捕获

#### 2.4.4 Nginx与后端通信

- **通信协议**：HTTP（容器内部通信）
- **代理方式**：反向代理
- **配置方式**：nginx配置文件中的proxy_pass指令

---

## 三、技术选型

### 3.1 后端技术栈

#### 3.1.1 Node.js

- **版本要求**：Node.js 18.x 或更高版本
- **选型理由**：
  - 与前端技术栈统一，降低学习成本
  - 异步I/O模型适合处理并发请求
  - 丰富的npm生态系统
  - 轻量级，适合容器化部署

#### 3.1.2 Web框架

- **推荐方案**：Express.js 或 Fastify
- **Express.js特点**：
  - 成熟稳定，生态丰富
  - 中间件机制灵活
  - 学习成本低
- **Fastify特点**：
  - 性能更高
  - 内置JSON Schema验证
  - 更适合高性能场景

#### 3.1.3 数据库操作库

- **SQLite库选择**：
  - **sqlite3**（推荐）：异步API，兼容性好，生态成熟
- **ORM选择**（可选）：
  - **Sequelize**：功能全面，支持多种数据库
  - **TypeORM**：TypeScript友好
  - **直接使用SQL**：简单场景下直接使用SQL更轻量

#### 3.1.4 认证库

- **Session管理**：
  - **express-session**：Express的Session中间件
  - **connect-sqlite3**：SQLite存储Session
- **JWT方案**（可选）：
  - **jsonwebtoken**：JWT生成和验证
  - **express-jwt**：Express的JWT中间件

#### 3.1.5 密码加密

- **bcrypt** 或 **bcryptjs**：密码哈希加密
- **argon2**（可选）：更现代的密码哈希算法

#### 3.1.6 SSH操作库

- **ssh2**：Node.js的SSH客户端库
  - 支持SSH连接、命令执行、文件传输
  - 支持密钥认证和密码认证
  - 用于SSH密钥生成和公钥推送

#### 3.1.7 进程管理

- **Node.js内置模块**：
  - **child_process**：spawn、exec等进程管理方法
  - **util.promisify**：将回调函数转换为Promise

#### 3.1.8 其他工具库

- **dotenv**：环境变量管理
- **cors**：跨域请求处理
- **helmet**：安全头设置
- **morgan**：HTTP请求日志
- **winston** 或 **pino**：日志管理

### 3.2 前端技术栈

#### 3.2.1 Vue 3

- **版本要求**：Vue 3.x
- **选型理由**：
  - 组合式API提供更好的代码组织
  - 性能优化（Proxy响应式系统）
  - TypeScript支持良好
  - 生态成熟

#### 3.2.2 构建工具

- **Vite**（推荐）：
  - 快速的热模块替换（HMR）
  - 快速的构建速度
  - 原生ES模块支持
  - 插件生态丰富

#### 3.2.3 UI组件库

- **Element Plus**：
  - Vue 3的Element UI升级版
  - 组件丰富，文档完善
  - 符合Material Design风格要求
  - 支持按需引入，减小打包体积

#### 3.2.4 状态管理

- **Pinia**（推荐）：
  - Vue 3官方推荐的状态管理库
  - 更简洁的API
  - TypeScript支持更好
  - 支持组合式API
- **Vuex**（备选）：
  - 成熟稳定
  - 生态丰富

#### 3.2.5 路由管理

- **Vue Router 4**：
  - Vue 3官方路由库
  - 支持组合式API
  - 路由守卫、懒加载等功能完善

#### 3.2.6 HTTP客户端

- **axios**：
  - 功能完善的HTTP客户端
  - 支持请求/响应拦截器
  - 支持Promise API
  - 浏览器和Node.js都支持

#### 3.2.7 代码高亮

- **highlight.js** 或 **prism.js**：
  - 用于PAC配置预览的JSON语法高亮
  - 支持多种语言
  - 轻量级，易于集成

#### 3.2.8 其他工具

- **TypeScript**（可选但推荐）：
  - 类型安全
  - 更好的IDE支持
  - 提高代码质量
- **ESLint** + **Prettier**：代码规范和格式化

### 3.3 数据库选型

#### 3.3.1 SQLite

- **选型理由**：
  - **轻量级**：无需单独的数据库服务，适合小型部署
  - **文件数据库**：数据存储在单个文件中，便于备份和迁移
  - **零配置**：无需安装和配置数据库服务器
  - **性能足够**：对于单用户或小规模使用场景，性能完全满足需求
  - **容器友好**：数据文件可以通过volume挂载实现持久化

#### 3.3.2 数据库版本

- **SQLite 3.x**：当前稳定版本
- **特性支持**：
  - 事务支持
  - 外键约束
  - 索引支持
  - JSON支持（SQLite 3.9+）

#### 3.3.3 数据存储位置

- **容器内路径**：`/data/database.db`
- **持久化方式**：通过Docker volume挂载到宿主机
- **备份策略**：定期备份数据库文件

### 3.4 代理服务技术

#### 3.4.1 autossh

- **功能**：自动重连SSH连接的工具
- **选型理由**：
  - 自动处理SSH连接断开和重连
  - 保持SSH隧道稳定运行
  - 轻量级，资源占用少
  - 广泛使用，稳定可靠

#### 3.4.2 SSH -D选项

- **功能**：SSH的动态端口转发，创建SOCKS代理
- **命令格式**：`ssh -D [bind_address:]port [user@]hostname`
- **工作原理**：
  - 在本地监听指定端口
  - 通过SSH隧道转发到远程服务器
  - 客户端连接本地端口，实际流量通过SSH隧道转发

#### 3.4.3 SSH密钥管理

- **密钥类型**：RSA 2048位或更高
- **密钥存储**：容器内`/data/ssh-keys/`目录
- **密钥命名**：`proxy-service-{service_id}`
- **权限控制**：私钥文件权限600，目录权限700

### 3.5 容器化技术

#### 3.5.1 Docker

- **版本要求**：Docker 20.10+
- **选型理由**：
  - 标准化部署
  - 环境隔离
  - 易于分发和部署
  - 支持多架构（x86、arm64）

#### 3.5.2 基础镜像选择

- **Node.js官方镜像**：
  - `node:18-alpine`（推荐）：Alpine Linux，体积小
  - `node:18-slim`：Debian slim，体积较小
  - `node:18`：完整版，体积较大但兼容性好

#### 3.5.3 多阶段构建

- **构建阶段**：
  1. **构建阶段**：安装依赖，构建前端和后端
  2. **运行阶段**：只包含运行时依赖和构建产物

#### 3.5.4 Web服务器

- **Nginx**：
  - 轻量级，性能好
  - 配置灵活
  - 支持反向代理和静态文件服务
  - 官方Alpine镜像体积小

#### 3.5.5 多架构支持

- **构建方式**：
  - **buildx**：Docker Buildx支持多架构构建
  - **manifest**：创建多架构镜像manifest
- **目标架构**：
  - `linux/amd64`：x86架构
  - `linux/arm64`：ARM64架构

---

## 四、数据库设计

### 4.1 数据库选型

采用SQLite 3.x作为数据库，具体选型理由见第三章技术选型章节。

**数据库文件位置**：`/data/database.db`（容器内路径）

**数据库初始化**：首次启动时自动创建数据库和表结构。

### 4.2 表结构设计

#### 4.2.1 用户表（users）

存储用户账户信息。

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | INTEGER | PRIMARY KEY AUTOINCREMENT | 用户ID |
| username | TEXT | UNIQUE NOT NULL | 用户名 |
| password_hash | TEXT | NOT NULL | 密码哈希值（bcrypt） |
| email | TEXT | UNIQUE | 邮箱（可选） |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 更新时间 |

**SQL创建语句**：
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 4.2.2 代理服务表（proxy_services）

存储代理服务配置信息。

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | INTEGER | PRIMARY KEY AUTOINCREMENT | 代理服务ID |
| name | TEXT | NOT NULL | 代理服务名称 |
| jump_host | TEXT | NOT NULL | 跳板服务器地址 |
| jump_port | INTEGER | NOT NULL DEFAULT 22 | 跳板服务器端口 |
| jump_username | TEXT | NOT NULL | 跳板服务器用户名 |
| proxy_port | INTEGER | NOT NULL UNIQUE | 本地代理端口（11081-11082） |
| ssh_key_path | TEXT | NOT NULL | SSH私钥文件路径 |
| status | TEXT | NOT NULL DEFAULT 'stopped' | 状态：running/stopped/error |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 更新时间 |

**状态枚举**：
- `running`：运行中
- `stopped`：已停止
- `error`：错误状态

**SQL创建语句**：
```sql
CREATE TABLE proxy_services (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    jump_host TEXT NOT NULL,
    jump_port INTEGER NOT NULL DEFAULT 22,
    jump_username TEXT NOT NULL,
    proxy_port INTEGER NOT NULL UNIQUE,
    ssh_key_path TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'stopped',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 4.2.3 Host配置表（host_configs）

存储Host代理配置信息。

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | INTEGER | PRIMARY KEY AUTOINCREMENT | Host配置ID |
| name | TEXT | NOT NULL | 配置名称 |
| proxy_service_id | INTEGER | NOT NULL | 关联的代理服务ID |
| hosts | TEXT | NOT NULL | Host列表（JSON数组格式） |
| created_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| updated_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 更新时间 |

**hosts字段格式**：JSON数组，例如：`["google.com", "youtube.com", "facebook.com"]`

**SQL创建语句**：
```sql
CREATE TABLE host_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    proxy_service_id INTEGER NOT NULL,
    hosts TEXT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (proxy_service_id) REFERENCES proxy_services(id) ON DELETE CASCADE
);
```

#### 4.2.4 系统配置表（system_configs）

存储系统全局配置参数。

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | INTEGER | PRIMARY KEY AUTOINCREMENT | 配置ID |
| key | TEXT | UNIQUE NOT NULL | 配置键 |
| value | TEXT | NOT NULL | 配置值（JSON格式） |
| description | TEXT | | 配置说明 |
| updated_at | DATETIME | NOT NULL DEFAULT CURRENT_TIMESTAMP | 更新时间 |

**预置配置项**：
- `register_enabled`：账号注册开关（boolean，默认true）

**SQL创建语句**：
```sql
CREATE TABLE system_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT UNIQUE NOT NULL,
    value TEXT NOT NULL,
    description TEXT,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

**初始化数据**：
```sql
INSERT INTO system_configs (key, value, description) 
VALUES ('register_enabled', 'true', '账号注册开关');
```

### 4.3 关系设计

#### 4.3.1 代理服务与Host配置的关系

- **关系类型**：一对多（One-to-Many）
- **关系说明**：
  - 一个代理服务可以被多个Host配置使用
  - 一个Host配置只能使用一个代理服务
  - 外键约束：`host_configs.proxy_service_id` → `proxy_services.id`
  - 删除策略：CASCADE（删除代理服务时，关联的Host配置也会被删除）

#### 4.3.2 用户与代理服务的关系

- **关系类型**：多对多（Many-to-Many）
- **当前设计**：由于需求中说明"所有用户都有完全的配置权限"，当前版本不区分用户，所有用户共享代理服务配置
- **未来扩展**：如需支持用户隔离，可添加`user_id`字段到`proxy_services`表

#### 4.3.3 Host配置的唯一性约束

- **业务规则**：不同Host配置中的host不能重叠
- **实现方式**：
  - 应用层校验：在创建/更新Host配置时，检查host是否已被其他配置使用
  - 数据库层：可以考虑使用触发器或应用层唯一性检查

### 4.4 索引设计

#### 4.4.1 用户表索引

```sql
-- 用户名索引（已通过UNIQUE约束自动创建）
-- 邮箱索引（已通过UNIQUE约束自动创建）
CREATE INDEX idx_users_created_at ON users(created_at);
```

#### 4.4.2 代理服务表索引

```sql
-- 代理端口索引（已通过UNIQUE约束自动创建）
CREATE INDEX idx_proxy_services_status ON proxy_services(status);
CREATE INDEX idx_proxy_services_created_at ON proxy_services(created_at);
```

#### 4.4.3 Host配置表索引

```sql
-- 代理服务ID索引（外键索引，通常自动创建）
CREATE INDEX idx_host_configs_proxy_service_id ON host_configs(proxy_service_id);
CREATE INDEX idx_host_configs_name ON host_configs(name);
```

#### 4.4.4 系统配置表索引

```sql
-- 配置键索引（已通过UNIQUE约束自动创建）
```

### 4.5 数据库迁移和版本管理

#### 4.5.1 版本管理策略

- 使用版本号管理数据库schema变更
- 创建`schema_migrations`表记录已执行的迁移

#### 4.5.2 迁移表结构

```sql
CREATE TABLE schema_migrations (
    version TEXT PRIMARY KEY,
    applied_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 4.5.3 初始化脚本

- 首次启动时检查数据库是否存在
- 不存在则创建所有表结构
- 记录初始版本号到`schema_migrations`表

---

## 五、后端API设计

### 5.1 API设计原则

#### 5.1.1 RESTful风格

- 使用标准HTTP方法：GET（查询）、POST（创建）、PUT（更新）、DELETE（删除）
- 资源使用名词，操作使用HTTP动词
- URL路径使用小写字母和连字符，例如：`/api/proxy-services`

#### 5.1.2 统一响应格式

**成功响应**：
```json
{
  "success": true,
  "data": { ... },
  "message": "操作成功"
}
```

**错误响应**：
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "错误描述"
  }
}
```

#### 5.1.3 API版本

- API路径前缀：`/api/v1`
- 未来版本升级：`/api/v2`

#### 5.1.4 认证方式

- 使用Session认证（或JWT Token）
- 需要认证的接口在请求头中携带Session Cookie（或Authorization头）

#### 5.1.5 分页和排序

- 列表接口支持分页：`?page=1&pageSize=10`
- 支持排序：`?sortBy=created_at&sortOrder=desc`

### 5.2 认证API

#### 5.2.1 用户注册

**POST** `/api/v1/auth/register`

**请求体**：
```json
{
  "username": "user123",
  "password": "password123",
  "email": "user@example.com" // 可选
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "username": "user123",
    "email": "user@example.com"
  },
  "message": "注册成功"
}
```

**错误情况**：
- 用户名已存在：`409 Conflict`
- 系统注册功能已关闭：`403 Forbidden`
- 参数验证失败：`400 Bad Request`

#### 5.2.2 用户登录

**POST** `/api/v1/auth/login`

**请求体**：
```json
{
  "username": "user123",
  "password": "password123"
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "user": {
      "id": 1,
      "username": "user123",
      "email": "user@example.com"
    }
  },
  "message": "登录成功"
}
```

**Session管理**：登录成功后设置Session Cookie

**错误情况**：
- 用户名或密码错误：`401 Unauthorized`
- 参数验证失败：`400 Bad Request`

#### 5.2.3 用户注销

**POST** `/api/v1/auth/logout`

**响应**：
```json
{
  "success": true,
  "message": "注销成功"
}
```

**功能**：清除Session

#### 5.2.4 获取当前用户信息

**GET** `/api/v1/auth/me`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "username": "user123",
    "email": "user@example.com",
    "created_at": "2024-01-01T00:00:00Z"
  }
}
```

**认证要求**：需要登录

### 5.3 用户管理API

#### 5.3.1 修改密码

**PUT** `/api/v1/users/password`

**请求体**：
```json
{
  "oldPassword": "oldpassword123",
  "newPassword": "newpassword123"
}
```

**响应**：
```json
{
  "success": true,
  "message": "密码修改成功"
}
```

**认证要求**：需要登录

**错误情况**：
- 旧密码错误：`401 Unauthorized`
- 参数验证失败：`400 Bad Request`

#### 5.3.2 更新用户信息

**PUT** `/api/v1/users/profile`

**请求体**：
```json
{
  "email": "newemail@example.com"
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "username": "user123",
    "email": "newemail@example.com"
  },
  "message": "更新成功"
}
```

**认证要求**：需要登录

### 5.4 代理服务管理API

#### 5.4.1 获取代理服务列表

**GET** `/api/v1/proxy-services`

**查询参数**：
- `page`：页码（默认1）
- `pageSize`：每页数量（默认10）
- `status`：状态筛选（running/stopped/error）

**响应**：
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": 1,
        "name": "默认代理",
        "jump_host": "192.168.1.1",
        "jump_port": 22,
        "jump_username": "user",
        "proxy_port": 11081,
        "status": "running",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    ],
    "total": 1,
    "page": 1,
    "pageSize": 10
  }
}
```

#### 5.4.2 获取代理服务详情

**GET** `/api/v1/proxy-services/:id`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "默认代理",
    "jump_host": "192.168.1.1",
    "jump_port": 22,
    "jump_username": "user",
    "proxy_port": 11081,
    "status": "running",
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z"
  }
}
```

**错误情况**：
- 代理服务不存在：`404 Not Found`

#### 5.4.3 创建代理服务

**POST** `/api/v1/proxy-services`

**请求体**：
```json
{
  "name": "默认代理",
  "jump_host": "192.168.1.1",
  "jump_port": 22,
  "jump_username": "user",
  "password": "password123",
  "hosts": ["google.com", "youtube.com"]
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "默认代理",
    "proxy_port": 11081,
    "status": "running",
    "host_config_id": 1
  },
  "message": "代理服务创建成功"
}
```

**功能说明**：
1. 生成SSH密钥对
2. 使用密码连接跳板服务器并推送公钥
3. 分配代理端口（11081-11082中选择未使用的）
4. 创建代理服务记录
5. 启动autossh进程
6. 自动创建Host配置（如果提供了hosts）

**错误情况**：
- SSH连接失败：`502 Bad Gateway`
- 端口已占用：`409 Conflict`
- 参数验证失败：`400 Bad Request`

#### 5.4.4 更新代理服务

**PUT** `/api/v1/proxy-services/:id`

**请求体**：
```json
{
  "name": "更新后的名称",
  "jump_host": "192.168.1.2",
  "jump_port": 22,
  "jump_username": "user",
  "password": "newpassword123" // 可选，如需更新密码
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "更新后的名称",
    "status": "running"
  },
  "message": "更新成功"
}
```

**功能说明**：
- 如果修改了跳板服务器信息或密码，需要重新推送公钥
- 如果代理服务正在运行，需要重启

#### 5.4.5 删除代理服务

**DELETE** `/api/v1/proxy-services/:id`

**响应**：
```json
{
  "success": true,
  "message": "删除成功"
}
```

**功能说明**：
1. 停止autossh进程
2. 删除SSH密钥文件
3. 删除关联的Host配置
4. 删除代理服务记录

#### 5.4.6 启动代理服务

**POST** `/api/v1/proxy-services/:id/start`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "status": "running"
  },
  "message": "启动成功"
}
```

#### 5.4.7 停止代理服务

**POST** `/api/v1/proxy-services/:id/stop`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "status": "stopped"
  },
  "message": "停止成功"
}
```

#### 5.4.8 获取代理服务状态

**GET** `/api/v1/proxy-services/:id/status`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "status": "running",
    "proxy_port": 11081,
    "process_id": 12345
  }
}
```

### 5.5 Host配置管理API

#### 5.5.1 获取Host配置列表

**GET** `/api/v1/host-configs`

**查询参数**：
- `page`：页码
- `pageSize`：每页数量
- `proxy_service_id`：按代理服务ID筛选

**响应**：
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "id": 1,
        "name": "默认配置",
        "proxy_service_id": 1,
        "proxy_service_name": "默认代理",
        "hosts": ["google.com", "youtube.com"],
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    ],
    "total": 1
  }
}
```

#### 5.5.2 获取Host配置详情

**GET** `/api/v1/host-configs/:id`

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "默认配置",
    "proxy_service_id": 1,
    "hosts": ["google.com", "youtube.com"]
  }
}
```

#### 5.5.3 创建Host配置

**POST** `/api/v1/host-configs`

**请求体**：
```json
{
  "name": "新配置",
  "proxy_service_id": 1,
  "hosts": ["facebook.com", "twitter.com"]
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 2,
    "name": "新配置",
    "proxy_service_id": 1,
    "hosts": ["facebook.com", "twitter.com"]
  },
  "message": "创建成功"
}
```

**验证规则**：
- hosts不能与现有配置重叠
- proxy_service_id必须存在

#### 5.5.4 更新Host配置

**PUT** `/api/v1/host-configs/:id`

**请求体**：
```json
{
  "name": "更新后的配置名",
  "proxy_service_id": 1,
  "hosts": ["google.com", "youtube.com", "chatgpt.com"]
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "更新后的配置名",
    "hosts": ["google.com", "youtube.com", "chatgpt.com"]
  },
  "message": "更新成功"
}
```

**功能说明**：
- 更新后自动重新生成PAC配置

#### 5.5.5 删除Host配置

**DELETE** `/api/v1/host-configs/:id`

**响应**：
```json
{
  "success": true,
  "message": "删除成功"
}
```

**功能说明**：
- 删除后自动重新生成PAC配置

#### 5.5.6 检查Host冲突

**POST** `/api/v1/host-configs/check-conflict`

**请求体**：
```json
{
  "hosts": ["google.com", "youtube.com"],
  "exclude_config_id": 1 // 可选，排除某个配置ID
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "hasConflict": false,
    "conflicts": []
  }
}
```

**冲突响应**：
```json
{
  "success": true,
  "data": {
    "hasConflict": true,
    "conflicts": [
      {
        "host": "google.com",
        "config_id": 2,
        "config_name": "其他配置"
      }
    ]
  }
}
```

### 5.6 PAC配置API

#### 5.6.1 获取PAC配置

**GET** `/api/v1/pac/config`

**响应**：
```json
{
  "success": true,
  "data": {
    "proxyRules": [
      {
        "domains": ["google.com", "youtube.com"],
        "proxy": "SOCKS5 192.168.1.4:11081"
      },
      {
        "domains": ["facebook.com", "twitter.com"],
        "proxy": "SOCKS5 192.168.1.4:11082"
      }
    ],
    "direct": true
  }
}
```

**说明**：返回JSON格式的PAC配置

#### 5.6.2 获取PAC文件（供客户端使用）

**GET** `/proxy.pac`

**响应**：JSON格式的PAC配置文件

**Content-Type**：`application/x-ns-proxy-autoconfig`

**说明**：此接口由nginx直接提供或通过后端API提供

### 5.7 系统配置API

#### 5.7.1 获取系统配置列表

**GET** `/api/v1/system-configs`

**响应**：
```json
{
  "success": true,
  "data": {
    "items": [
      {
        "key": "register_enabled",
        "value": true,
        "description": "账号注册开关"
      }
    ]
  }
}
```

#### 5.7.2 获取单个系统配置

**GET** `/api/v1/system-configs/:key`

**响应**：
```json
{
  "success": true,
  "data": {
    "key": "register_enabled",
    "value": true,
    "description": "账号注册开关"
  }
}
```

#### 5.7.3 更新系统配置

**PUT** `/api/v1/system-configs/:key`

**请求体**：
```json
{
  "value": false
}
```

**响应**：
```json
{
  "success": true,
  "data": {
    "key": "register_enabled",
    "value": false
  },
  "message": "更新成功"
}
```

**认证要求**：需要登录

### 5.8 API错误处理

#### 5.8.1 HTTP状态码

- `200 OK`：请求成功
- `201 Created`：创建成功
- `400 Bad Request`：请求参数错误
- `401 Unauthorized`：未认证或认证失败
- `403 Forbidden`：权限不足
- `404 Not Found`：资源不存在
- `409 Conflict`：资源冲突（如用户名已存在、端口已占用）
- `500 Internal Server Error`：服务器内部错误
- `502 Bad Gateway`：网关错误（如SSH连接失败）

#### 5.8.2 错误响应格式

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "错误描述",
    "details": {} // 可选，详细错误信息
  }
}
```

#### 5.8.3 常见错误码

- `VALIDATION_ERROR`：参数验证失败
- `USER_NOT_FOUND`：用户不存在
- `INVALID_CREDENTIALS`：用户名或密码错误
- `USERNAME_EXISTS`：用户名已存在
- `PROXY_SERVICE_NOT_FOUND`：代理服务不存在
- `PROXY_PORT_OCCUPIED`：代理端口已被占用
- `SSH_CONNECTION_FAILED`：SSH连接失败
- `SSH_AUTH_FAILED`：SSH认证失败
- `HOST_CONFLICT`：Host配置冲突
- `REGISTER_DISABLED`：注册功能已关闭

---

## 六、前端架构设计

### 6.1 UI设计引用说明

**重要提示**：前端UI设计的详细规范请参考`docs/UI前端设计.md`。本文档仅包含前端技术架构和实现相关的设计。

`docs/UI前端设计.md`文档包含了完整的前端UI设计规范，包括：

- 整体布局设计
- 各个组件的详细设计规范（代理配置卡片、标签页、弹窗等）
- 交互细节设计
- 响应式设计
- UI风格规范（Material Design、颜色、字体、间距等）
- 组件清单

在开发过程中，前端开发人员应同时参考：
1. 本文档的技术架构设计（项目结构、状态管理、路由设计等）
2. `docs/UI前端设计.md`的UI设计规范（组件设计、样式规范、交互细节等）

确保实现既符合技术架构要求，又符合UI设计规范。

### 6.2 技术栈说明

前端技术栈详见第三章技术选型章节，主要包括：

- **Vue 3**：前端框架
- **Vite**：构建工具
- **Element Plus**：UI组件库
- **Pinia**：状态管理
- **Vue Router 4**：路由管理
- **axios**：HTTP客户端
- **highlight.js**：代码高亮（PAC配置预览）

### 6.3 项目结构

```
server/front-end/
├── public/                 # 静态资源
│   ├── index.html
│   └── favicon.ico
├── src/
│   ├── assets/            # 资源文件（图片、样式等）
│   │   ├── styles/        # 全局样式
│   │   └── images/        # 图片资源
│   ├── components/        # 公共组件
│   │   ├── Layout/        # 布局组件
│   │   │   ├── Header.vue      # 顶部导航栏
│   │   │   ├── Sidebar.vue     # 左侧边栏
│   │   │   └── Main.vue        # 主内容区
│   │   ├── ProxyConfigCard.vue # 代理配置卡片
│   │   ├── PACPreview.vue      # PAC配置预览
│   │   ├── HostConfigTab.vue   # Host配置标签页
│   │   ├── ProxyServiceDialog.vue # 代理服务弹窗
│   │   ├── CodeViewer.vue      # 代码查看器（JSON高亮）
│   │   ├── ProcessLogViewer.vue # 过程日志查看器
│   │   └── ...
│   ├── views/             # 页面组件
│   │   ├── Login.vue      # 登录页
│   │   ├── Register.vue  # 注册页
│   │   ├── Dashboard.vue # 主面板（Socks代理管理）
│   │   ├── SystemConfig.vue # 系统配置页
│   │   ├── Profile.vue    # 个人中心页
│   │   └── OtherModulesPlaceholder.vue # 其他模块占位页
│   ├── stores/            # Pinia状态管理
│   │   ├── auth.js        # 认证状态
│   │   ├── proxyService.js # 代理服务状态
│   │   ├── hostConfig.js  # Host配置状态
│   │   └── systemConfig.js # 系统配置状态
│   ├── router/            # 路由配置
│   │   └── index.js
│   ├── api/               # API接口封装
│   │   ├── auth.js        # 认证API
│   │   ├── proxyService.js # 代理服务API
│   │   ├── hostConfig.js  # Host配置API
│   │   ├── pac.js         # PAC配置API
│   │   └── systemConfig.js # 系统配置API
│   ├── utils/             # 工具函数
│   │   ├── request.js     # axios封装
│   │   ├── auth.js        # 认证工具
│   │   └── ...
│   ├── App.vue            # 根组件
│   └── main.js            # 入口文件
├── .env.development      # 开发环境配置
├── .env.production       # 生产环境配置
├── vite.config.js       # Vite配置
├── package.json          # 依赖配置
└── README.md            # 项目说明
```

### 6.4 状态管理

使用Pinia进行状态管理，主要包含以下store：

#### 6.4.1 认证Store（auth.js）

**状态**：
- `user`：当前用户信息
- `isAuthenticated`：是否已认证
- `token`：认证token（如果使用JWT）

**方法**：
- `login(username, password)`：登录
- `logout()`：注销
- `register(userData)`：注册
- `updateProfile(userData)`：更新个人信息
- `changePassword(oldPassword, newPassword)`：修改密码

#### 6.4.2 代理服务Store（proxyService.js）

**状态**：
- `proxyServices`：代理服务列表
- `currentProxyService`：当前选中的代理服务
- `loading`：加载状态

**方法**：
- `fetchProxyServices()`：获取代理服务列表
- `getProxyService(id)`：获取代理服务详情
- `createProxyService(data)`：创建代理服务
- `updateProxyService(id, data)`：更新代理服务
- `deleteProxyService(id)`：删除代理服务
- `startProxyService(id)`：启动代理服务
- `stopProxyService(id)`：停止代理服务
- `getProxyServiceStatus(id)`：获取代理服务状态

#### 6.4.3 Host配置Store（hostConfig.js）

**状态**：
- `hostConfigs`：Host配置列表
- `currentHostConfig`：当前选中的Host配置
- `loading`：加载状态

**方法**：
- `fetchHostConfigs()`：获取Host配置列表
- `getHostConfig(id)`：获取Host配置详情
- `createHostConfig(data)`：创建Host配置
- `updateHostConfig(id, data)`：更新Host配置
- `deleteHostConfig(id)`：删除Host配置
- `checkHostConflict(hosts, excludeConfigId)`：检查Host冲突

#### 6.4.4 PAC配置Store（pac.js）

**状态**：
- `pacConfig`：当前PAC配置
- `loading`：加载状态

**方法**：
- `fetchPACConfig()`：获取PAC配置
- `generatePACConfig()`：重新生成PAC配置

#### 6.4.5 系统配置Store（systemConfig.js）

**状态**：
- `systemConfigs`：系统配置列表
- `registerEnabled`：注册开关状态

**方法**：
- `fetchSystemConfigs()`：获取系统配置列表
- `getSystemConfig(key)`：获取单个系统配置
- `updateSystemConfig(key, value)`：更新系统配置

#### 6.4.6 标签页Store（tabs.js）

**状态**：
- `tabs`：打开的标签页列表
- `activeTab`：当前激活的标签页

**方法**：
- `addTab(tab)`：添加标签页
- `removeTab(tabId)`：移除标签页
- `setActiveTab(tabId)`：设置激活标签页
- `closeAllTabs()`：关闭所有标签页

### 6.5 路由设计

#### 6.5.1 路由结构

```javascript
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('@/views/Register.vue'),
    meta: { requiresAuth: false, checkRegisterEnabled: true }
  },
  {
    path: '/',
    component: () => import('@/components/Layout/Main.vue'),
    redirect: '/dashboard',
    meta: { requiresAuth: true },
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/Dashboard.vue'),
        meta: { title: 'Socks代理' }
      },
      {
        path: 'other-modules',
        name: 'OtherModules',
        component: () => import('@/views/OtherModulesPlaceholder.vue'),
        meta: { title: '其他模块' }
      },
      {
        path: 'system-config',
        name: 'SystemConfig',
        component: () => import('@/views/SystemConfig.vue'),
        meta: { title: '系统配置' }
      },
      {
        path: 'profile',
        name: 'Profile',
        component: () => import('@/views/Profile.vue'),
        meta: { title: '个人中心' }
      }
    ]
  }
]
```

#### 6.5.2 路由守卫

**全局前置守卫**：
- 检查认证状态：未登录用户重定向到登录页
- 检查注册开关：注册功能关闭时禁止访问注册页
- 设置页面标题

**路由元信息**：
- `requiresAuth`：是否需要认证
- `checkRegisterEnabled`：是否需要检查注册开关
- `title`：页面标题

#### 6.5.3 路由懒加载

所有路由组件使用懒加载，提高首屏加载速度：

```javascript
component: () => import('@/views/Dashboard.vue')
```

### 6.6 API封装

#### 6.6.1 axios封装（utils/request.js）

**功能**：
- 请求/响应拦截器
- 统一错误处理
- 自动添加认证token
- 请求超时处理

**示例**：
```javascript
import axios from 'axios'
import { useAuthStore } from '@/stores/auth'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 30000
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    const authStore = useAuthStore()
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    return config
  },
  error => Promise.reject(error)
)

// 响应拦截器
request.interceptors.response.use(
  response => response.data,
  error => {
    // 统一错误处理
    if (error.response?.status === 401) {
      // 未认证，跳转到登录页
      const authStore = useAuthStore()
      authStore.logout()
      router.push('/login')
    }
    return Promise.reject(error)
  }
)

export default request
```

#### 6.6.2 API模块封装

每个功能模块独立的API文件，例如`api/proxyService.js`：

```javascript
import request from '@/utils/request'

export const proxyServiceApi = {
  getList(params) {
    return request.get('/api/v1/proxy-services', { params })
  },
  getById(id) {
    return request.get(`/api/v1/proxy-services/${id}`)
  },
  create(data) {
    return request.post('/api/v1/proxy-services', data)
  },
  update(id, data) {
    return request.put(`/api/v1/proxy-services/${id}`, data)
  },
  delete(id) {
    return request.delete(`/api/v1/proxy-services/${id}`)
  },
  start(id) {
    return request.post(`/api/v1/proxy-services/${id}/start`)
  },
  stop(id) {
    return request.post(`/api/v1/proxy-services/${id}/stop`)
  }
}
```

### 6.7 环境配置

#### 6.7.1 环境变量文件

**.env.development**：
```
VITE_API_BASE_URL=http://localhost:3000
```

**.env.production**：
```
VITE_API_BASE_URL=/api
```

#### 6.7.2 构建配置

**vite.config.js**：
- 代理配置（开发环境）
- 构建优化配置
- 插件配置（Element Plus按需引入等）

---

## 七、代理服务实现

### 7.1 SSH密钥管理

#### 7.1.1 密钥生成

**生成时机**：创建代理服务时

**密钥类型**：RSA 2048位或更高

**生成方式**：使用Node.js的`child_process`模块调用`ssh-keygen`命令

**生成命令**：
```bash
ssh-keygen -t rsa -b 2048 -f /data/ssh-keys/proxy-service-{service_id} -N "" -C "proxy-service-{service_id}"
```

**参数说明**：
- `-t rsa`：密钥类型为RSA
- `-b 2048`：密钥长度为2048位
- `-f`：密钥文件路径
- `-N ""`：无密码短语
- `-C`：注释信息

**密钥文件**：
- 私钥：`/data/ssh-keys/proxy-service-{service_id}`
- 公钥：`/data/ssh-keys/proxy-service-{service_id}.pub`

**文件权限**：
- 私钥：600（仅所有者可读写）
- 公钥：644（所有者可读写，其他用户可读）
- 目录：700（仅所有者可访问）

#### 7.1.2 公钥推送

**推送时机**：创建代理服务时，使用用户提供的密码进行一次性推送

**推送方式**：使用`ssh2`库连接跳板服务器，执行命令将公钥添加到`~/.ssh/authorized_keys`

**推送流程**：
1. 使用密码连接跳板服务器
2. 读取公钥内容
3. 检查`~/.ssh/authorized_keys`文件是否存在，不存在则创建
4. 检查公钥是否已存在，不存在则追加
5. 设置正确的文件权限（`~/.ssh`目录700，`authorized_keys`文件600）

**实现示例**（使用ssh2库）：
```javascript
const { Client } = require('ssh2');

const conn = new Client();
conn.on('ready', () => {
  const publicKey = fs.readFileSync(publicKeyPath, 'utf8');
  conn.exec(`mkdir -p ~/.ssh && chmod 700 ~/.ssh && 
             echo "${publicKey}" >> ~/.ssh/authorized_keys && 
             chmod 600 ~/.ssh/authorized_keys`, (err, stream) => {
    // 处理结果
  });
}).connect({
  host: jumpHost,
  port: jumpPort,
  username: jumpUsername,
  password: password
});
```

#### 7.1.3 密钥存储

**存储位置**：`/data/ssh-keys/`目录（容器内）

**持久化**：通过Docker volume挂载到宿主机，确保容器重启后密钥不丢失

**密钥命名规则**：`proxy-service-{service_id}`

**密钥清理**：删除代理服务时，同时删除对应的密钥文件

### 7.2 autossh进程管理

#### 7.2.1 autossh命令格式

**基本命令**：
```bash
autossh -M {monitor_port} -f -N -D {local_port} -i {private_key_path} {username}@{host} -p {port}
```

**参数说明**：
- `-M {monitor_port}`：监控端口（用于检测连接状态，0表示使用随机端口）
- `-f`：后台运行
- `-N`：不执行远程命令，仅用于端口转发
- `-D {local_port}`：动态端口转发（SOCKS代理）
- `-i {private_key_path}`：私钥文件路径
- `{username}@{host}`：跳板服务器地址
- `-p {port}`：跳板服务器端口

**完整示例**：
```bash
autossh -M 0 -f -N -D 11081 -i /data/ssh-keys/proxy-service-1 user@192.168.1.1 -p 22
```

#### 7.2.2 进程启动

**启动方式**：使用Node.js的`child_process.spawn`启动autossh进程

**实现示例**：
```javascript
const { spawn } = require('child_process');

const autosshProcess = spawn('autossh', [
  '-M', '0',
  '-f',
  '-N',
  '-D', proxyPort.toString(),
  '-i', privateKeyPath,
  `${username}@${host}`,
  '-p', port.toString()
], {
  stdio: ['ignore', 'pipe', 'pipe']
});

// 记录进程ID
const pid = autosshProcess.pid;
```

**进程ID存储**：将进程ID存储到数据库或文件中，用于后续管理

#### 7.2.3 进程停止

**停止方式**：使用`kill`命令发送SIGTERM信号

**实现示例**：
```javascript
const { exec } = require('child_process');

exec(`kill ${pid}`, (error) => {
  if (error) {
    // 处理错误
  }
});
```

**优雅停止**：先发送SIGTERM，等待进程退出；如果超时，再发送SIGKILL强制终止

#### 7.2.4 进程状态检查

**检查方式**：
1. 检查进程是否存在：使用`ps`命令或`kill -0`命令
2. 检查端口是否监听：使用`netstat`或`ss`命令
3. 检查SSH连接：尝试连接本地代理端口

**实现示例**：
```javascript
const { exec } = require('child_process');

function checkProcessStatus(pid) {
  return new Promise((resolve) => {
    exec(`kill -0 ${pid}`, (error) => {
      if (error) {
        resolve('stopped');
      } else {
        // 进一步检查端口监听
        exec(`netstat -tln | grep :${proxyPort}`, (err, stdout) => {
          resolve(stdout ? 'running' : 'error');
        });
      }
    });
  });
}
```

### 7.3 代理服务生命周期

#### 7.3.1 创建流程

1. **验证输入参数**
   - 验证跳板服务器地址、端口、用户名
   - 验证代理服务名称唯一性

2. **分配代理端口**
   - 从可用端口池（11081-11082）中选择未使用的端口
   - 检查端口是否被占用

3. **生成SSH密钥**
   - 调用`ssh-keygen`生成密钥对
   - 保存密钥文件路径到数据库

4. **推送公钥**
   - 使用用户提供的密码连接跳板服务器
   - 将公钥添加到`~/.ssh/authorized_keys`

5. **创建数据库记录**
   - 插入代理服务记录到数据库
   - 状态设置为`stopped`

6. **启动autossh进程**
   - 启动autossh进程
   - 记录进程ID
   - 更新状态为`running`

7. **创建Host配置**（如果提供了hosts）
   - 自动创建Host配置记录
   - 关联到新创建的代理服务

8. **返回结果**
   - 返回创建的代理服务信息

#### 7.3.2 更新流程

1. **验证输入参数**
   - 验证更新的字段

2. **检查是否需要重新推送公钥**
   - 如果跳板服务器信息或密码发生变化，需要重新推送公钥

3. **更新数据库记录**
   - 更新代理服务信息

4. **重启代理服务**（如果正在运行）
   - 停止当前autossh进程
   - 启动新的autossh进程

5. **返回结果**

#### 7.3.3 删除流程

1. **停止autossh进程**
   - 查找并停止关联的autossh进程

2. **删除SSH密钥**
   - 删除私钥和公钥文件

3. **删除关联的Host配置**
   - 删除所有关联的Host配置记录

4. **删除数据库记录**
   - 删除代理服务记录

5. **重新生成PAC配置**
   - 由于Host配置变化，重新生成PAC配置

#### 7.3.4 启动流程

1. **检查代理服务状态**
   - 如果已在运行，返回错误

2. **验证配置完整性**
   - 检查密钥文件是否存在
   - 检查跳板服务器信息是否完整

3. **启动autossh进程**
   - 启动autossh进程
   - 记录进程ID

4. **更新状态**
   - 更新数据库状态为`running`

#### 7.3.5 停止流程

1. **查找autossh进程**
   - 根据进程ID或端口查找进程

2. **停止进程**
   - 发送SIGTERM信号停止进程

3. **更新状态**
   - 更新数据库状态为`stopped`

### 7.4 端口管理

#### 7.4.1 端口池配置

**可用端口范围**：11081-11082（默认2个端口）

**配置方式**：可以通过环境变量或配置文件配置

**端口分配策略**：
1. 按顺序查找可用端口
2. 检查端口是否被占用（通过`netstat`或`ss`命令）
3. 检查数据库中是否有其他服务使用该端口

#### 7.4.2 端口分配

**分配流程**：
1. 查询数据库中已使用的端口
2. 检查系统端口占用情况
3. 从端口池中选择第一个未使用的端口
4. 如果所有端口都被占用，返回错误

**实现示例**：
```javascript
async function allocateProxyPort() {
  const portPool = [11081, 11082];
  const usedPorts = await db.query('SELECT proxy_port FROM proxy_services');
  const usedPortSet = new Set(usedPorts.map(r => r.proxy_port));
  
  for (const port of portPool) {
    if (!usedPortSet.has(port) && await isPortAvailable(port)) {
      return port;
    }
  }
  throw new Error('No available proxy port');
}
```

#### 7.4.3 端口释放

**释放时机**：删除代理服务时

**释放流程**：
1. 停止使用该端口的autossh进程
2. 从数据库中删除记录
3. 端口自动释放，可供其他服务使用

#### 7.4.4 端口检查

**检查方式**：
- 使用`netstat -tln | grep :{port}`检查端口监听
- 使用`ss -tln | grep :{port}`检查端口监听
- 使用Node.js的`net`模块尝试连接端口

### 7.5 状态监控

#### 7.5.1 状态类型

- **running**：运行中（进程存在且端口监听正常）
- **stopped**：已停止（进程不存在）
- **error**：错误状态（进程存在但端口未监听，或连接失败）

#### 7.5.2 状态检查机制

**定期检查**：
- 后端服务定期（如每30秒）检查所有代理服务的状态
- 检查进程是否存在
- 检查端口是否监听
- 更新数据库中的状态

**实时检查**：
- 用户请求状态时，实时检查当前状态
- 返回最新的状态信息

#### 7.5.3 状态更新

**更新时机**：
- 创建代理服务后
- 启动/停止代理服务后
- 定期检查后
- 用户请求状态时

**更新方式**：
- 更新数据库中的`status`字段
- 通过WebSocket或轮询通知前端（可选）

#### 7.5.4 错误处理

**连接失败处理**：
- 如果SSH连接失败，状态设置为`error`
- 记录错误日志
- 前端显示错误提示

**进程异常退出处理**：
- 检测到进程异常退出时，状态设置为`stopped`
- 记录日志
- 可选：自动重启（需要配置）

#### 7.5.5 日志记录

**日志内容**：
- 代理服务创建、启动、停止、删除操作
- 进程启动和停止时间
- 错误信息和异常情况
- SSH连接状态

**日志存储**：
- 文件日志：`/data/logs/proxy-services.log`
- 数据库日志表（可选）：记录关键操作历史

---

## 八、PAC配置生成

### 8.1 PAC配置格式

#### 8.1.1 PAC文件格式说明

PAC（Proxy Auto-Config）文件是JavaScript格式的配置文件，用于自动配置代理设置。本项目采用JSON格式的PAC配置，便于前端解析和显示。

#### 8.1.2 JSON格式定义

**配置结构**：
```json
{
  "proxyRules": [
    {
      "domains": ["google.com", "youtube.com", "google.co.jp"],
      "proxy": "SOCKS5 192.168.1.4:11081"
    },
    {
      "domains": ["facebook.com", "twitter.com"],
      "proxy": "SOCKS5 192.168.1.4:11082"
    }
  ],
  "direct": true
}
```

**字段说明**：
- `proxyRules`：代理规则数组
  - `domains`：域名列表（数组）
  - `proxy`：代理服务器地址（格式：`SOCKS5 host:port`）
- `direct`：是否允许直连（boolean，true表示其他域名直连）

#### 8.1.3 代理地址格式

**格式**：`SOCKS5 {host}:{port}`

**说明**：
- `SOCKS5`：代理协议类型
- `{host}`：代理服务器地址（容器IP或宿主机IP）
- `{port}`：代理端口（11081-11082）

**示例**：
- `SOCKS5 192.168.1.4:11081`
- `SOCKS5 127.0.0.1:11081`（容器内访问）

#### 8.1.4 域名匹配规则

**精确匹配**：配置中的域名与请求域名完全匹配

**子域名匹配**（可选扩展）：
- `google.com`匹配`www.google.com`、`mail.google.com`等
- 实现方式：检查请求域名是否以配置域名结尾

**通配符匹配**（可选扩展）：
- 支持`*.google.com`格式
- 实现方式：将通配符转换为正则表达式

### 8.2 生成逻辑

#### 8.2.1 生成流程

1. **查询所有Host配置**
   - 从数据库查询所有Host配置记录
   - 包含关联的代理服务信息

2. **构建代理规则**
   - 遍历每个Host配置
   - 获取关联的代理服务信息（IP、端口）
   - 构建代理规则对象

3. **生成JSON配置**
   - 将代理规则数组组装成JSON对象
   - 设置`direct`字段为`true`

4. **保存配置**
   - 保存到文件：`/data/pac/config.json`
   - 或存储到数据库（可选）

5. **返回配置**
   - 返回JSON配置供前端显示
   - 或通过nginx提供文件服务

#### 8.2.2 生成算法

**伪代码**：
```javascript
function generatePACConfig() {
  // 1. 查询所有Host配置
  const hostConfigs = db.query(`
    SELECT hc.*, ps.proxy_port, ps.status
    FROM host_configs hc
    JOIN proxy_services ps ON hc.proxy_service_id = ps.id
    WHERE ps.status = 'running'
    ORDER BY hc.id
  `);
  
  // 2. 获取代理服务地址
  const proxyHost = getProxyHost(); // 容器IP或宿主机IP
  
  // 3. 构建代理规则
  const proxyRules = hostConfigs.map(config => {
    const hosts = JSON.parse(config.hosts);
    return {
      domains: hosts,
      proxy: `SOCKS5 ${proxyHost}:${config.proxy_port}`
    };
  });
  
  // 4. 生成配置
  const pacConfig = {
    proxyRules: proxyRules,
    direct: true
  };
  
  // 5. 保存配置
  fs.writeFileSync('/data/pac/config.json', JSON.stringify(pacConfig, null, 2));
  
  return pacConfig;
}
```

#### 8.2.3 代理服务地址获取

**获取方式**：
1. **环境变量**：通过环境变量`PROXY_HOST`配置
2. **自动检测**：检测容器IP或宿主机IP
3. **用户配置**：用户在UI中配置（前端显示的可编辑地址）

**优先级**：
1. 用户配置的地址（如果存在）
2. 环境变量配置
3. 自动检测的IP地址

**实现示例**：
```javascript
function getProxyHost() {
  // 1. 检查用户配置
  const userConfig = getSystemConfig('proxy_host');
  if (userConfig) return userConfig;
  
  // 2. 检查环境变量
  if (process.env.PROXY_HOST) return process.env.PROXY_HOST;
  
  // 3. 自动检测（简化示例）
  return '192.168.1.4'; // 默认IP
}
```

#### 8.2.4 Host去重处理

**问题**：不同Host配置可能包含相同的域名

**处理策略**：
- **策略1**：后创建的配置覆盖先创建的（简单实现）
- **策略2**：检测冲突，不允许重复（推荐）
- **策略3**：合并相同域名的配置（复杂，不推荐）

**推荐实现**：在创建/更新Host配置时检查冲突，确保域名唯一性

### 8.3 实时更新机制

#### 8.3.1 更新触发时机

**自动触发**：
1. 创建Host配置后
2. 更新Host配置后
3. 删除Host配置后
4. 代理服务状态变化后（启动/停止）
5. 代理服务删除后

**手动触发**：
- 用户点击"刷新PAC配置"按钮（可选）

#### 8.3.2 更新实现

**同步更新**：
- 在数据库操作后立即调用生成函数
- 确保配置实时更新

**异步更新**（可选）：
- 使用消息队列或事件机制
- 提高响应速度

**实现示例**：
```javascript
// 在Host配置更新后
async function updateHostConfig(id, data) {
  // 1. 更新数据库
  await db.update('host_configs', id, data);
  
  // 2. 重新生成PAC配置
  await generatePACConfig();
  
  // 3. 返回结果
  return result;
}
```

#### 8.3.3 前端更新通知

**轮询方式**：
- 前端定期（如每5秒）请求PAC配置
- 检查配置是否有更新

**WebSocket方式**（可选）：
- 后端配置更新后通过WebSocket通知前端
- 前端实时更新显示

**事件驱动方式**（推荐）：
- 前端在Host配置操作后，主动请求最新PAC配置
- 更新标签页中的PAC预览

#### 8.3.4 配置缓存

**缓存策略**：
- 后端缓存生成的配置JSON
- 避免频繁查询数据库和文件IO

**缓存失效**：
- 配置更新时清除缓存
- 重新生成配置

**实现示例**：
```javascript
let pacConfigCache = null;

function getPACConfig() {
  if (pacConfigCache) {
    return pacConfigCache;
  }
  pacConfigCache = generatePACConfig();
  return pacConfigCache;
}

function invalidatePACCache() {
  pacConfigCache = null;
}
```

### 8.4 配置验证

#### 8.4.1 JSON格式验证

**验证内容**：
- JSON格式是否正确
- 必需字段是否存在
- 字段类型是否正确

**实现示例**：
```javascript
function validatePACConfig(config) {
  if (!config.proxyRules || !Array.isArray(config.proxyRules)) {
    throw new Error('Invalid proxyRules');
  }
  
  for (const rule of config.proxyRules) {
    if (!rule.domains || !Array.isArray(rule.domains)) {
      throw new Error('Invalid domains');
    }
    if (!rule.proxy || typeof rule.proxy !== 'string') {
      throw new Error('Invalid proxy');
    }
    // 验证代理格式
    if (!/^SOCKS5 \d+\.\d+\.\d+\.\d+:\d+$/.test(rule.proxy)) {
      throw new Error('Invalid proxy format');
    }
  }
  
  if (typeof config.direct !== 'boolean') {
    throw new Error('Invalid direct field');
  }
}
```

#### 8.4.2 代理服务状态验证

**验证内容**：
- 只包含运行中的代理服务
- 排除已停止或错误的代理服务

**实现**：
- 在生成配置时，只查询`status = 'running'`的代理服务
- 确保PAC配置中的代理服务都是可用的

#### 8.4.3 域名格式验证

**验证规则**：
- 域名格式正确（如`google.com`）
- 不包含协议前缀（如`http://`）
- 不包含路径（如`/path`）

**实现示例**：
```javascript
function validateDomain(domain) {
  const domainRegex = /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i;
  return domainRegex.test(domain);
}
```

#### 8.4.4 配置完整性检查

**检查内容**：
- 至少有一个代理规则（如果存在Host配置）
- 代理服务地址和端口有效
- 域名列表不为空

**错误处理**：
- 如果配置无效，返回错误信息
- 前端显示错误提示
- 记录错误日志

---

## 九、用户认证与授权

### 9.1 认证机制

#### 9.1.1 认证方式选择

**方案1：Session认证**（推荐）

**优点**：
- 实现简单
- 服务端可控，安全性高
- 适合单容器部署场景

**实现方式**：
- 使用`express-session`中间件
- Session存储到SQLite数据库（`connect-sqlite3`）
- Cookie设置HttpOnly和Secure标志

**方案2：JWT Token认证**（可选）

**优点**：
- 无状态，适合分布式部署
- 跨域支持好

**缺点**：
- Token撤销需要额外机制
- 单容器场景下优势不明显

**推荐**：采用Session认证，简单可靠

#### 9.1.2 用户注册

**注册流程**：
1. 检查系统注册开关（`register_enabled`）
2. 验证用户名唯一性
3. 验证密码强度（可选）
4. 密码加密（bcrypt）
5. 创建用户记录
6. 自动登录（可选）或返回登录页面

**密码加密**：
- 使用`bcrypt`或`bcryptjs`库
- 加密轮数：10（默认）
- 存储哈希值到数据库

**实现示例**：
```javascript
const bcrypt = require('bcryptjs');

async function registerUser(username, password, email) {
  // 1. 检查注册开关
  const registerEnabled = await getSystemConfig('register_enabled');
  if (!registerEnabled) {
    throw new Error('注册功能已关闭');
  }
  
  // 2. 检查用户名唯一性
  const existingUser = await db.get('SELECT id FROM users WHERE username = ?', [username]);
  if (existingUser) {
    throw new Error('用户名已存在');
  }
  
  // 3. 密码加密
  const passwordHash = await bcrypt.hash(password, 10);
  
  // 4. 创建用户
  const result = await db.run(
    'INSERT INTO users (username, password_hash, email) VALUES (?, ?, ?)',
    [username, passwordHash, email]
  );
  
  return { id: result.lastInsertRowid, username, email };
}
```

#### 9.1.3 用户登录

**登录流程**：
1. 验证用户名和密码
2. 密码比对（bcrypt.compare）
3. 创建Session
4. 设置Session Cookie
5. 返回用户信息

**实现示例**：
```javascript
async function loginUser(req, username, password) {
  // 1. 查询用户
  const user = await db.get('SELECT * FROM users WHERE username = ?', [username]);
  if (!user) {
    throw new Error('用户名或密码错误');
  }
  
  // 2. 验证密码
  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) {
    throw new Error('用户名或密码错误');
  }
  
  // 3. 创建Session
  req.session.userId = user.id;
  req.session.username = user.username;
  
  // 4. 返回用户信息（不包含密码）
  return {
    id: user.id,
    username: user.username,
    email: user.email
  };
}
```

#### 9.1.4 认证中间件

**实现示例**：
```javascript
function requireAuth(req, res, next) {
  if (req.session && req.session.userId) {
    return next();
  }
  return res.status(401).json({
    success: false,
    error: {
      code: 'UNAUTHORIZED',
      message: '未登录'
    }
  });
}
```

**使用方式**：
```javascript
app.get('/api/v1/proxy-services', requireAuth, getProxyServices);
```

### 9.2 会话管理

#### 9.2.1 Session配置

**配置项**：
- `secret`：Session密钥（环境变量）
- `name`：Cookie名称（默认`connect.sid`）
- `resave`：是否强制保存（false）
- `saveUninitialized`：是否保存未初始化的Session（false）
- `cookie.secure`：HTTPS only（生产环境）
- `cookie.httpOnly`：防止XSS攻击（true）
- `cookie.maxAge`：过期时间（24小时）

**实现示例**：
```javascript
const session = require('express-session');
const SQLiteStore = require('connect-sqlite3')(session);

app.use(session({
  store: new SQLiteStore({
    db: '/data/database.db',
    table: 'sessions'
  }),
  secret: process.env.SESSION_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24小时
  }
}));
```

#### 9.2.2 Session存储

**存储方式**：SQLite数据库

**表结构**（由connect-sqlite3自动创建）：
- `sid`：Session ID（主键）
- `sess`：Session数据（JSON）
- `expire`：过期时间

**优点**：
- 持久化存储
- 容器重启后Session不丢失
- 便于管理和清理

#### 9.2.3 Session清理

**自动清理**：
- connect-sqlite3自动清理过期Session

**手动清理**（可选）：
- 定期任务清理过期Session
- 用户注销时清除Session

#### 9.2.4 注销流程

**实现示例**：
```javascript
app.post('/api/v1/auth/logout', requireAuth, (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({
        success: false,
        error: { message: '注销失败' }
      });
    }
    res.clearCookie('connect.sid');
    res.json({
      success: true,
      message: '注销成功'
    });
  });
});
```

### 9.3 权限设计

#### 9.3.1 权限模型

**当前版本**：所有用户拥有完全权限

**权限说明**：
- 所有登录用户都可以：
  - 创建、删除、管理代理服务
  - 创建、删除、管理Host配置
  - 查看和修改系统配置
  - 管理自己的个人信息

**设计理由**：
- 单用户或小规模使用场景
- 简化权限管理
- 符合需求文档要求："所有用户都有完全的配置权限"

#### 9.3.2 权限检查

**检查方式**：
- 所有需要认证的接口使用`requireAuth`中间件
- 不需要额外的权限检查逻辑

**实现示例**：
```javascript
// 所有管理接口都需要登录
app.get('/api/v1/proxy-services', requireAuth, getProxyServices);
app.post('/api/v1/proxy-services', requireAuth, createProxyService);
app.put('/api/v1/system-configs/:key', requireAuth, updateSystemConfig);
```

#### 9.3.3 未来扩展（可选）

**如果需要用户隔离**：
- 在`proxy_services`和`host_configs`表中添加`user_id`字段
- 查询时过滤当前用户的资源
- 实现用户级别的权限控制

**如果需要角色权限**：
- 添加`roles`表
- 添加`user_roles`关联表
- 实现基于角色的访问控制（RBAC）

### 9.4 安全措施

#### 9.4.1 密码安全

**密码加密**：
- 使用bcrypt哈希算法
- 加密轮数：10（可配置）
- 不存储明文密码

**密码策略**（可选）：
- 最小长度：8位
- 复杂度要求：包含字母和数字
- 密码强度提示

**实现示例**：
```javascript
function validatePassword(password) {
  if (password.length < 8) {
    return { valid: false, message: '密码长度至少8位' };
  }
  if (!/^(?=.*[a-zA-Z])(?=.*\d)/.test(password)) {
    return { valid: false, message: '密码必须包含字母和数字' };
  }
  return { valid: true };
}
```

#### 9.4.2 Session安全

**Cookie安全**：
- `httpOnly`：防止JavaScript访问Cookie
- `secure`：HTTPS only（生产环境）
- `sameSite`：防止CSRF攻击

**Session固定攻击防护**：
- 登录后重新生成Session ID

**实现示例**：
```javascript
app.post('/api/v1/auth/login', async (req, res) => {
  // 登录成功后重新生成Session ID
  req.session.regenerate((err) => {
    if (err) {
      return res.status(500).json({ success: false });
    }
    // 设置用户信息
    req.session.userId = user.id;
    res.json({ success: true, data: user });
  });
});
```

#### 9.4.3 输入验证

**验证内容**：
- 参数类型和格式
- SQL注入防护（使用参数化查询）
- XSS防护（输入转义）

**实现示例**：
```javascript
// 使用参数化查询防止SQL注入
const user = await db.get('SELECT * FROM users WHERE username = ?', [username]);

// 输入验证
function validateUsername(username) {
  if (!username || username.length < 3 || username.length > 20) {
    throw new Error('用户名长度必须在3-20字符之间');
  }
  if (!/^[a-zA-Z0-9_]+$/.test(username)) {
    throw new Error('用户名只能包含字母、数字和下划线');
  }
}
```

#### 9.4.4 请求限制

**频率限制**（可选）：
- 登录失败次数限制
- API请求频率限制

**实现示例**（使用express-rate-limit）：
```javascript
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5, // 最多5次尝试
  message: '登录失败次数过多，请稍后再试'
});

app.post('/api/v1/auth/login', loginLimiter, loginUser);
```

#### 9.4.5 HTTPS支持

**生产环境**：
- 使用HTTPS协议
- 配置SSL证书
- 强制HTTPS重定向

**开发环境**：
- 可以使用HTTP
- 或使用自签名证书

#### 9.4.6 安全头设置

**使用helmet中间件**：
```javascript
const helmet = require('helmet');
app.use(helmet());
```

**安全头包括**：
- X-Content-Type-Options
- X-Frame-Options
- X-XSS-Protection
- Strict-Transport-Security（HTTPS）

#### 9.4.7 日志记录

**安全日志**：
- 记录登录成功/失败
- 记录敏感操作（创建/删除代理服务等）
- 记录异常访问

**日志格式**：
```
[2024-01-01 12:00:00] [INFO] User login: username=user123, ip=192.168.1.100
[2024-01-01 12:01:00] [WARN] Login failed: username=user123, ip=192.168.1.100
[2024-01-01 12:02:00] [INFO] Proxy service created: id=1, user=user123
```

---

## 十、Docker构建方案

### 10.1 Dockerfile设计

#### 10.1.1 基础镜像选择

**推荐方案**：`node:18-alpine`

**理由**：
- Alpine Linux体积小（约5MB）
- Node.js 18 LTS版本稳定
- 最终镜像体积小，适合小型设备部署

**备选方案**：
- `node:18-slim`：Debian slim版本，体积稍大但兼容性好
- `node:18`：完整版本，体积最大但兼容性最好

#### 10.1.2 多阶段构建结构

**阶段1：构建阶段（builder）**
- 安装构建依赖
- 构建前端项目
- 安装后端依赖

**阶段2：运行阶段（runtime）**
- 复制构建产物
- 安装运行时依赖
- 安装nginx和autossh
- 配置启动脚本

#### 10.1.3 Dockerfile示例

```dockerfile
# ==================== 构建阶段 ====================
FROM node:18-alpine AS builder

# 安装构建工具
RUN apk add --no-cache python3 make g++

WORKDIR /build

# 复制前端项目
COPY server/front-end/package*.json ./front-end/
WORKDIR /build/front-end
RUN npm ci
COPY server/front-end .
RUN npm run build

# 复制后端项目
WORKDIR /build
COPY server/back-end/package*.json ./back-end/
WORKDIR /build/back-end
RUN npm ci --production
COPY server/back-end .

# ==================== 运行阶段 ====================
FROM node:18-alpine AS runtime

# 安装运行时依赖
RUN apk add --no-cache \
    nginx \
    openssh-client \
    autossh \
    supervisor

# 创建应用目录
WORKDIR /app

# 复制后端代码和依赖
COPY --from=builder /build/back-end .

# 复制前端构建产物
COPY --from=builder /build/front-end/dist /usr/share/nginx/html

# 复制nginx配置
COPY docker/nginx.conf /etc/nginx/nginx.conf
COPY docker/nginx-site.conf /etc/nginx/conf.d/default.conf

# 复制supervisor配置
COPY docker/supervisord.conf /etc/supervisor/conf.d/supervisord.conf

# 创建数据目录
RUN mkdir -p /data/{database,ssh-keys,logs,pac} && \
    chmod 700 /data/ssh-keys

# 复制启动脚本
COPY docker/entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

# 暴露端口
EXPOSE 8090 11081 11082

# 启动服务
ENTRYPOINT ["/entrypoint.sh"]
CMD ["supervisord", "-c", "/etc/supervisor/conf.d/supervisord.conf"]
```

### 10.2 多阶段构建

#### 10.2.1 构建阶段优化

**前端构建**：
- 只安装生产依赖
- 使用Vite构建优化
- 启用代码压缩和tree-shaking

**后端依赖**：
- 使用`npm ci --production`只安装生产依赖
- 排除开发依赖（如测试工具、构建工具）

#### 10.2.2 运行阶段优化

**最小化镜像**：
- 只复制必要的文件
- 不包含源代码（仅构建产物）
- 不包含node_modules中的开发依赖

**层缓存优化**：
- 先复制package.json，安装依赖
- 再复制源代码
- 利用Docker层缓存加速构建

### 10.3 镜像优化

#### 10.3.1 体积优化

**优化措施**：
1. 使用Alpine基础镜像
2. 多阶段构建，只保留运行时文件
3. 清理不必要的文件和缓存
4. 合并RUN命令减少层数

**优化示例**：
```dockerfile
# 合并RUN命令
RUN apk add --no-cache nginx openssh-client autossh && \
    mkdir -p /data/{database,ssh-keys,logs,pac} && \
    chmod 700 /data/ssh-keys && \
    rm -rf /var/cache/apk/*
```

#### 10.3.2 构建速度优化

**优化措施**：
1. 利用Docker层缓存
2. 使用.dockerignore排除不必要文件
3. 并行构建（如果支持）

**.dockerignore示例**：
```
node_modules
npm-debug.log
.git
.gitignore
.env
.env.local
*.md
docs/
imgs/
.vscode/
.idea/
```

#### 10.3.3 安全性优化

**优化措施**：
1. 使用非root用户运行应用
2. 最小权限原则
3. 定期更新基础镜像

**非root用户示例**：
```dockerfile
# 创建非root用户
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# 修改文件所有者
RUN chown -R appuser:appuser /app /data

# 切换到非root用户
USER appuser
```

### 10.4 多架构支持（x86、arm64）

#### 10.4.1 构建方式

**使用Docker Buildx**：
- Docker Buildx支持多架构构建
- 创建builder实例
- 构建多架构镜像

#### 10.4.2 构建命令

**创建builder实例**：
```bash
docker buildx create --name multiarch --use
docker buildx inspect --bootstrap
```

**构建多架构镜像**：
```bash
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t your-registry/socks-proxy:latest \
  --push .
```

**本地构建**（单架构）：
```bash
docker buildx build \
  --platform linux/amd64 \
  -t socks-proxy:latest \
  --load .
```

#### 10.4.3 架构特定优化

**x86架构**：
- 使用标准镜像
- 无特殊优化

**arm64架构**：
- 确保所有依赖支持arm64
- 测试autossh在arm64上的兼容性
- 验证Node.js模块的arm64支持

#### 10.4.4 镜像清单（Manifest）

**创建多架构清单**：
```bash
docker manifest create your-registry/socks-proxy:latest \
  --amend your-registry/socks-proxy:amd64 \
  --amend your-registry/socks-proxy:arm64

docker manifest push your-registry/socks-proxy:latest
```

**验证清单**：
```bash
docker manifest inspect your-registry/socks-proxy:latest
```

### 10.5 构建脚本

#### 10.5.1 build.sh脚本设计

**脚本功能**：
1. 检查Docker环境
2. 设置构建参数（host、port）
3. 构建Docker镜像
4. 可选：推送镜像到仓库

**脚本示例**：
```bash
#!/bin/bash

set -e

# 默认配置
PROXY_HOST=${PROXY_HOST:-$(hostname -I | awk '{print $1}')}
PROXY_PORT=${PROXY_PORT:-8090}
IMAGE_NAME=${IMAGE_NAME:-socks-proxy}
IMAGE_TAG=${IMAGE_TAG:-latest}

# 解析命令行参数
while [[ $# -gt 0 ]]; do
  case $1 in
    --host)
      PROXY_HOST="$2"
      shift 2
      ;;
    --port)
      PROXY_PORT="$2"
      shift 2
      ;;
    --image)
      IMAGE_NAME="$2"
      shift 2
      ;;
    --tag)
      IMAGE_TAG="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

echo "Building Docker image..."
echo "  Host: $PROXY_HOST"
echo "  Port: $PROXY_PORT"
echo "  Image: $IMAGE_NAME:$IMAGE_TAG"

# 构建镜像
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  --build-arg PROXY_HOST=$PROXY_HOST \
  --build-arg PROXY_PORT=$PROXY_PORT \
  -t $IMAGE_NAME:$IMAGE_TAG \
  --load \
  .

echo "Build completed!"
```

#### 10.5.2 构建参数

**通过ARG传递**：
```dockerfile
ARG PROXY_HOST
ARG PROXY_PORT

ENV PROXY_HOST=${PROXY_HOST}
ENV PROXY_PORT=${PROXY_PORT}
```

**使用方式**：
```bash
docker build --build-arg PROXY_HOST=192.168.1.4 --build-arg PROXY_PORT=8090 .
```

### 10.6 镜像标签策略

#### 10.6.1 标签命名

**版本标签**：
- `latest`：最新版本
- `v1.0.0`：语义化版本
- `v1.0.0-amd64`：架构特定版本

**构建标签**：
- `build-{timestamp}`：构建时间戳
- `git-{commit-hash}`：Git提交哈希

#### 10.6.2 版本管理

**语义化版本**：
- 主版本号：不兼容的API修改
- 次版本号：向下兼容的功能性新增
- 修订号：向下兼容的问题修正

**示例**：
- `v1.0.0`：初始版本
- `v1.1.0`：新增功能
- `v1.1.1`：Bug修复

---

## 十一、部署方案

### 11.1 build.sh脚本设计

#### 11.1.1 脚本功能

**主要功能**：
1. 检查Docker环境
2. 获取或设置代理服务地址（host、port）
3. 构建Docker镜像
4. 可选：创建和启动容器

#### 11.1.2 脚本实现

**完整脚本示例**：
```bash
#!/bin/bash

set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 默认配置
PROXY_HOST=""
PROXY_PORT=8090
IMAGE_NAME="socks-proxy"
IMAGE_TAG="latest"
CONTAINER_NAME="socks-proxy"
DATA_DIR="./data"

# 帮助信息
show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --host HOST         代理服务地址（默认：自动检测本机IP）"
    echo "  --port PORT         代理服务端口（默认：8090）"
    echo "  --image NAME        镜像名称（默认：socks-proxy）"
    echo "  --tag TAG           镜像标签（默认：latest）"
    echo "  --container NAME    容器名称（默认：socks-proxy）"
    echo "  --data-dir DIR      数据目录（默认：./data）"
    echo "  --run               构建后立即运行容器"
    echo "  --help              显示帮助信息"
    echo ""
    echo "Examples:"
    echo "  $0 --host 192.168.1.4 --port 8090"
    echo "  $0 --host 192.168.1.4 --run"
}

# 解析命令行参数
RUN_CONTAINER=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --host)
            PROXY_HOST="$2"
            shift 2
            ;;
        --port)
            PROXY_PORT="$2"
            shift 2
            ;;
        --image)
            IMAGE_NAME="$2"
            shift 2
            ;;
        --tag)
            IMAGE_TAG="$2"
            shift 2
            ;;
        --container)
            CONTAINER_NAME="$2"
            shift 2
            ;;
        --data-dir)
            DATA_DIR="$2"
            shift 2
            ;;
        --run)
            RUN_CONTAINER=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            show_help
            exit 1
            ;;
    esac
done

# 检查Docker环境
if ! command -v docker &> /dev/null; then
    echo -e "${RED}Error: Docker is not installed${NC}"
    exit 1
fi

# 自动检测IP地址
if [ -z "$PROXY_HOST" ]; then
    echo -e "${YELLOW}Detecting host IP address...${NC}"
    if command -v hostname &> /dev/null; then
        PROXY_HOST=$(hostname -I | awk '{print $1}')
    elif command -v ip &> /dev/null; then
        PROXY_HOST=$(ip route get 8.8.8.8 | awk '{print $7; exit}')
    else
        echo -e "${RED}Error: Cannot detect host IP. Please specify --host${NC}"
        exit 1
    fi
    echo -e "${GREEN}Detected IP: $PROXY_HOST${NC}"
fi

# 显示配置信息
echo ""
echo -e "${GREEN}=== Build Configuration ===${NC}"
echo "  Host: $PROXY_HOST"
echo "  Port: $PROXY_PORT"
echo "  Image: $IMAGE_NAME:$IMAGE_TAG"
echo "  Container: $CONTAINER_NAME"
echo "  Data Directory: $DATA_DIR"
echo ""

# 创建数据目录
mkdir -p "$DATA_DIR"/{database,ssh-keys,logs,pac}
chmod 700 "$DATA_DIR/ssh-keys"

# 构建镜像
echo -e "${YELLOW}Building Docker image...${NC}"
docker build \
    --build-arg PROXY_HOST="$PROXY_HOST" \
    --build-arg PROXY_PORT="$PROXY_PORT" \
    -t "$IMAGE_NAME:$IMAGE_TAG" \
    .

if [ $? -eq 0 ]; then
    echo -e "${GREEN}Build completed successfully!${NC}"
else
    echo -e "${RED}Build failed!${NC}"
    exit 1
fi

# 运行容器
if [ "$RUN_CONTAINER" = true ]; then
    echo ""
    echo -e "${YELLOW}Starting container...${NC}"
    
    # 停止并删除旧容器（如果存在）
    if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "Stopping existing container..."
        docker stop "$CONTAINER_NAME" > /dev/null 2>&1 || true
        docker rm "$CONTAINER_NAME" > /dev/null 2>&1 || true
    fi
    
    # 启动新容器
    docker run -d \
        --name "$CONTAINER_NAME" \
        -p "$PROXY_PORT:8090" \
        -p 11081:11081 \
        -p 11082:11082 \
        -v "$(pwd)/$DATA_DIR/database:/data/database" \
        -v "$(pwd)/$DATA_DIR/ssh-keys:/data/ssh-keys" \
        -v "$(pwd)/$DATA_DIR/logs:/data/logs" \
        -v "$(pwd)/$DATA_DIR/pac:/data/pac" \
        "$IMAGE_NAME:$IMAGE_TAG"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Container started successfully!${NC}"
        echo ""
        echo "Access the web interface at: http://$PROXY_HOST:$PROXY_PORT"
        echo "PAC file URL: http://$PROXY_HOST:$PROXY_PORT/proxy.pac"
    else
        echo -e "${RED}Failed to start container!${NC}"
        exit 1
    fi
fi
```

#### 11.1.3 使用示例

**基本构建**：
```bash
./build.sh --host 192.168.1.4 --port 8090
```

**构建并运行**：
```bash
./build.sh --host 192.168.1.4 --port 8090 --run
```

**自动检测IP**：
```bash
./build.sh --run
```

### 11.2 容器启动配置

#### 11.2.1 docker run命令

**基本命令**：
```bash
docker run -d \
  --name socks-proxy \
  -p 8090:8090 \
  -p 11081:11081 \
  -p 11082:11082 \
  -v ./data/database:/data/database \
  -v ./data/ssh-keys:/data/ssh-keys \
  -v ./data/logs:/data/logs \
  -v ./data/pac:/data/pac \
  socks-proxy:latest
```

**参数说明**：
- `-d`：后台运行
- `--name`：容器名称
- `-p`：端口映射（宿主机:容器）
- `-v`：数据卷挂载

#### 11.2.2 docker-compose配置

**docker-compose.yml示例**：
```yaml
version: '3.8'

services:
  socks-proxy:
    image: socks-proxy:latest
    container_name: socks-proxy
    restart: unless-stopped
    ports:
      - "8090:8090"
      - "11081:11081"
      - "11082:11082"
    volumes:
      - ./data/database:/data/database
      - ./data/ssh-keys:/data/ssh-keys
      - ./data/logs:/data/logs
      - ./data/pac:/data/pac
    environment:
      - PROXY_HOST=192.168.1.4
      - PROXY_PORT=8090
      - NODE_ENV=production
      - SESSION_SECRET=your-secret-key-here
    networks:
      - proxy-network

networks:
  proxy-network:
    driver: bridge
```

**启动命令**：
```bash
docker-compose up -d
```

#### 11.2.3 Supervisor配置

**supervisord.conf示例**：
```ini
[supervisord]
nodaemon=true
user=root

[program:nginx]
command=nginx -g "daemon off;"
autostart=true
autorestart=true
stdout_logfile=/data/logs/nginx.log
stderr_logfile=/data/logs/nginx.error.log

[program:nodejs]
command=node /app/server.js
directory=/app
autostart=true
autorestart=true
stdout_logfile=/data/logs/nodejs.log
stderr_logfile=/data/logs/nodejs.error.log
environment=NODE_ENV=production
```

### 11.3 环境变量配置

#### 11.3.1 必需环境变量

**PROXY_HOST**：
- 代理服务地址（容器IP或宿主机IP）
- 用于生成PAC配置中的代理地址
- 默认：自动检测

**PROXY_PORT**：
- 代理服务端口
- 默认：8090

#### 11.3.2 可选环境变量

**NODE_ENV**：
- 运行环境（development/production）
- 默认：production

**SESSION_SECRET**：
- Session加密密钥
- 默认：随机生成（不推荐，应设置固定值）

**DATABASE_PATH**：
- 数据库文件路径
- 默认：/data/database.db

**LOG_LEVEL**：
- 日志级别（debug/info/warn/error）
- 默认：info

#### 11.3.3 环境变量使用

**在Dockerfile中**：
```dockerfile
ARG PROXY_HOST
ARG PROXY_PORT
ENV PROXY_HOST=${PROXY_HOST}
ENV PROXY_PORT=${PROXY_PORT}
```

**在应用中读取**：
```javascript
const proxyHost = process.env.PROXY_HOST || '192.168.1.4';
const proxyPort = process.env.PROXY_PORT || 8090;
```

### 11.4 数据持久化

#### 11.4.1 数据目录结构

```
data/
├── database/
│   └── database.db          # SQLite数据库
├── ssh-keys/                # SSH密钥目录
│   ├── proxy-service-1      # 代理服务1的私钥
│   └── proxy-service-1.pub # 代理服务1的公钥
├── logs/                    # 日志目录
│   ├── nginx.log
│   ├── nodejs.log
│   └── proxy-services.log
└── pac/                     # PAC配置目录
    └── config.json          # PAC配置文件
```

#### 11.4.2 Volume挂载

**挂载配置**：
```bash
-v ./data/database:/data/database
-v ./data/ssh-keys:/data/ssh-keys
-v ./data/logs:/data/logs
-v ./data/pac:/data/pac
```

**权限设置**：
- `ssh-keys`目录：700权限
- 私钥文件：600权限
- 其他目录：755权限

#### 11.4.3 数据备份

**备份策略**：
1. 定期备份数据库文件
2. 备份SSH密钥（重要）
3. 备份配置文件

**备份脚本示例**：
```bash
#!/bin/bash
BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

# 备份数据库
cp ./data/database/database.db "$BACKUP_DIR/database_$TIMESTAMP.db"

# 备份SSH密钥
tar -czf "$BACKUP_DIR/ssh-keys_$TIMESTAMP.tar.gz" ./data/ssh-keys/

echo "Backup completed: $BACKUP_DIR"
```

### 11.5 nginx配置

#### 11.5.1 nginx.conf主配置

```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    
    include /etc/nginx/conf.d/*.conf;
}
```

#### 11.5.2 站点配置（nginx-site.conf）

```nginx
server {
    listen 8090;
    server_name _;
    
    # 前端静态文件
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    # PAC文件服务
    location /proxy.pac {
        alias /data/pac/config.json;
        add_header Content-Type application/x-ns-proxy-autoconfig;
        add_header Access-Control-Allow-Origin *;
    }
    
    # 后端API代理
    location /api/ {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # 健康检查
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

#### 11.5.3 配置说明

**前端静态文件**：
- 根目录：`/usr/share/nginx/html`
- SPA路由支持：`try_files $uri $uri/ /index.html`

**PAC文件服务**：
- 直接提供JSON文件
- 设置正确的Content-Type
- 允许跨域访问（CORS）

**后端API代理**：
- 代理到Node.js服务（端口3000）
- 传递真实IP和协议信息
- 支持WebSocket升级（如需要）

### 11.6 启动脚本（entrypoint.sh）

**entrypoint.sh示例**：
```bash
#!/bin/sh
set -e

# 初始化数据库（如果不存在）
if [ ! -f /data/database/database.db ]; then
    echo "Initializing database..."
    node /app/scripts/init-db.js
fi

# 设置权限
chmod 700 /data/ssh-keys
chmod 600 /data/ssh-keys/* 2>/dev/null || true

# 启动supervisor
exec "$@"
```

**功能**：
1. 检查并初始化数据库
2. 设置文件权限
3. 启动supervisor管理所有服务

---

## 十二、开发阶段划分

### 12.1 第一阶段开发计划

#### 12.1.1 阶段目标

在本地开发环境中完成前后端开发，包括：
- 前端项目（Vue 3 + Element Plus）
- 后端项目（Node.js + Express）
- 数据库设计和实现
- 代理服务管理功能
- Host配置管理功能
- PAC配置生成功能
- 用户认证功能

#### 12.1.2 开发任务清单

**1. 项目初始化**
- [ ] 创建项目目录结构
- [ ] 初始化前端项目（Vite + Vue 3）
- [ ] 初始化后端项目（Node.js + Express）
- [ ] 配置开发环境
- [ ] 配置Git仓库

**2. 数据库设计实现**
- [ ] 创建数据库初始化脚本
- [ ] 实现数据库迁移机制
- [ ] 创建所有数据表
- [ ] 实现数据库操作封装

**3. 后端API开发**
- [ ] 实现用户认证API（注册、登录、注销）
- [ ] 实现用户管理API（修改密码、更新信息）
- [ ] 实现代理服务管理API（CRUD、启动、停止）
- [ ] 实现Host配置管理API（CRUD、冲突检查）
- [ ] 实现PAC配置API（生成、获取）
- [ ] 实现系统配置API（获取、更新）
- [ ] 实现API错误处理中间件

**4. 代理服务实现**
- [ ] 实现SSH密钥生成功能
- [ ] 实现SSH公钥推送功能
- [ ] 实现autossh进程管理
- [ ] 实现端口分配和管理
- [ ] 实现代理服务状态监控
- [ ] 实现代理服务生命周期管理

**5. PAC配置生成**
- [ ] 实现PAC配置生成逻辑
- [ ] 实现配置实时更新机制
- [ ] 实现配置验证功能
- [ ] 实现配置文件服务

**6. 前端开发**
- [ ] 实现项目基础架构（路由、状态管理、API封装）
- [ ] 实现登录/注册页面
- [ ] 实现主面板布局（Header、Sidebar、Main）
- [ ] 实现代理配置卡片组件
- [ ] 实现代理服务弹窗组件（创建/编辑）
- [ ] 实现Host配置标签页组件
- [ ] 实现PAC配置预览组件
- [ ] 实现系统配置页面
- [ ] 实现个人中心页面
- [ ] 实现其他模块占位页面

**7. 用户认证实现**
- [ ] 实现Session认证机制
- [ ] 实现密码加密（bcrypt）
- [ ] 实现认证中间件
- [ ] 实现路由守卫（前端）

**8. 测试和调试**
- [ ] 单元测试（后端API）
- [ ] 集成测试（前后端联调）
- [ ] UI测试（前端功能）
- [ ] 代理服务功能测试
- [ ] Bug修复和优化

#### 12.1.3 开发环境配置

**前端开发环境**：
- Node.js 18+
- npm或yarn
- Vite开发服务器
- 热模块替换（HMR）

**后端开发环境**：
- Node.js 18+
- SQLite数据库
- 开发服务器（nodemon）
- API测试工具（Postman或curl）

**代理服务测试环境**：
- 准备测试用的跳板服务器
- SSH访问权限
- 测试域名列表

#### 12.1.4 交付物

**代码**：
- `server/front-end/`：前端项目完整代码
- `server/back-end/`：后端项目完整代码

**文档**：
- API文档
- 开发文档
- 部署文档（第一阶段）

### 12.2 第二阶段开发计划

#### 12.2.1 阶段目标

构建Docker容器，实现一键部署功能，包括：
- Dockerfile编写
- 多阶段构建优化
- build.sh脚本开发
- nginx配置
- 容器启动配置
- 多架构支持（x86、arm64）

#### 12.2.2 开发任务清单

**1. Dockerfile开发**
- [ ] 设计多阶段构建流程
- [ ] 编写构建阶段Dockerfile
- [ ] 编写运行阶段Dockerfile
- [ ] 优化镜像体积
- [ ] 测试构建流程

**2. 配置文件开发**
- [ ] nginx配置文件
- [ ] supervisor配置文件
- [ ] 启动脚本（entrypoint.sh）
- [ ] 环境变量配置

**3. build.sh脚本开发**
- [ ] 实现参数解析
- [ ] 实现IP自动检测
- [ ] 实现镜像构建
- [ ] 实现容器启动（可选）
- [ ] 添加错误处理

**4. 多架构支持**
- [ ] 配置Docker Buildx
- [ ] 测试x86架构构建
- [ ] 测试arm64架构构建
- [ ] 创建多架构镜像清单

**5. 数据持久化**
- [ ] 设计数据目录结构
- [ ] 配置Volume挂载
- [ ] 实现数据备份脚本
- [ ] 测试数据持久化

**6. 部署测试**
- [ ] 本地部署测试
- [ ] 不同环境部署测试
- [ ] 性能测试
- [ ] 稳定性测试

**7. 文档完善**
- [ ] 更新部署文档
- [ ] 编写使用手册
- [ ] 编写故障排查文档

#### 12.2.3 交付物

**Docker相关**：
- `Dockerfile`：Docker镜像构建文件
- `build.sh`：构建和部署脚本
- `docker-compose.yml`：Docker Compose配置（可选）
- `docker/`：Docker相关配置文件目录

**文档**：
- 部署文档
- 使用手册
- 故障排查文档

### 12.3 测试策略

#### 12.3.1 单元测试

**后端测试**：
- API接口单元测试
- 数据库操作测试
- 业务逻辑测试
- 使用框架：Jest或Mocha

**前端测试**：
- 组件单元测试
- 工具函数测试
- 使用框架：Vitest或Jest

**测试覆盖率目标**：≥70%

#### 12.3.2 集成测试

**前后端集成测试**：
- API调用测试
- 数据流测试
- 认证流程测试

**代理服务集成测试**：
- SSH连接测试
- 代理服务创建测试
- 代理服务启动/停止测试
- PAC配置生成测试

#### 12.3.3 功能测试

**用户功能测试**：
- 用户注册/登录
- 代理服务管理（创建、编辑、删除、启动、停止）
- Host配置管理（创建、编辑、删除）
- PAC配置查看
- 系统配置管理

**UI测试**：
- 页面布局测试
- 交互功能测试
- 响应式设计测试
- 浏览器兼容性测试

#### 12.3.4 性能测试

**测试指标**：
- API响应时间
- 页面加载时间
- 代理服务启动时间
- 内存占用
- CPU占用

**测试工具**：
- Apache Bench（ab）
- k6
- Chrome DevTools

#### 12.3.5 安全测试

**测试内容**：
- SQL注入测试
- XSS攻击测试
- CSRF攻击测试
- 认证绕过测试
- 权限控制测试

**测试工具**：
- OWASP ZAP
- Burp Suite

#### 12.3.6 部署测试

**测试场景**：
- 首次部署测试
- 容器重启测试
- 数据持久化测试
- 多架构部署测试
- 不同环境部署测试（Linux、macOS、Windows）

#### 12.3.7 测试计划

**第一阶段测试**：
- 开发过程中持续进行单元测试
- 功能完成后进行集成测试
- 阶段结束前进行完整功能测试

**第二阶段测试**：
- Docker构建测试
- 部署流程测试
- 生产环境模拟测试
- 性能压力测试

#### 12.3.8 Bug管理

**Bug分类**：
- P0：严重错误，系统无法使用
- P1：重要功能错误，影响主要功能
- P2：一般功能错误，影响次要功能
- P3：界面或体验问题

**Bug处理流程**：
1. 发现Bug并记录
2. 分配优先级
3. 修复Bug
4. 验证修复
5. 关闭Bug

### 12.4 开发时间估算

#### 12.4.1 第一阶段时间估算

- **项目初始化**：1-2天
- **数据库设计实现**：2-3天
- **后端API开发**：10-15天
- **代理服务实现**：5-7天
- **PAC配置生成**：2-3天
- **前端开发**：15-20天
- **用户认证实现**：3-5天
- **测试和调试**：5-7天

**总计**：约43-62天（约2-3个月）

#### 12.4.2 第二阶段时间估算

- **Dockerfile开发**：3-5天
- **配置文件开发**：2-3天
- **build.sh脚本开发**：2-3天
- **多架构支持**：3-5天
- **数据持久化**：2-3天
- **部署测试**：5-7天
- **文档完善**：2-3天

**总计**：约19-29天（约1个月）

#### 12.4.3 总体时间估算

**开发总时间**：约62-91天（约3-4个月）

**说明**：
- 时间估算基于单人开发
- 团队开发可并行进行，缩短时间
- 实际时间可能因需求变更、技术难点等因素有所调整

---

## 十三、附录

### 13.1 API接口清单

#### 13.1.1 认证API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| POST | `/api/v1/auth/register` | 用户注册 | 否 |
| POST | `/api/v1/auth/login` | 用户登录 | 否 |
| POST | `/api/v1/auth/logout` | 用户注销 | 是 |
| GET | `/api/v1/auth/me` | 获取当前用户信息 | 是 |

#### 13.1.2 用户管理API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| PUT | `/api/v1/users/password` | 修改密码 | 是 |
| PUT | `/api/v1/users/profile` | 更新用户信息 | 是 |

#### 13.1.3 代理服务管理API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| GET | `/api/v1/proxy-services` | 获取代理服务列表 | 是 |
| GET | `/api/v1/proxy-services/:id` | 获取代理服务详情 | 是 |
| POST | `/api/v1/proxy-services` | 创建代理服务 | 是 |
| PUT | `/api/v1/proxy-services/:id` | 更新代理服务 | 是 |
| DELETE | `/api/v1/proxy-services/:id` | 删除代理服务 | 是 |
| POST | `/api/v1/proxy-services/:id/start` | 启动代理服务 | 是 |
| POST | `/api/v1/proxy-services/:id/stop` | 停止代理服务 | 是 |
| GET | `/api/v1/proxy-services/:id/status` | 获取代理服务状态 | 是 |

#### 13.1.4 Host配置管理API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| GET | `/api/v1/host-configs` | 获取Host配置列表 | 是 |
| GET | `/api/v1/host-configs/:id` | 获取Host配置详情 | 是 |
| POST | `/api/v1/host-configs` | 创建Host配置 | 是 |
| PUT | `/api/v1/host-configs/:id` | 更新Host配置 | 是 |
| DELETE | `/api/v1/host-configs/:id` | 删除Host配置 | 是 |
| POST | `/api/v1/host-configs/check-conflict` | 检查Host冲突 | 是 |

#### 13.1.5 PAC配置API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| GET | `/api/v1/pac/config` | 获取PAC配置（JSON） | 是 |
| GET | `/proxy.pac` | 获取PAC文件 | 否 |

#### 13.1.6 系统配置API

| 方法 | 路径 | 说明 | 认证 |
|------|------|------|------|
| GET | `/api/v1/system-configs` | 获取系统配置列表 | 是 |
| GET | `/api/v1/system-configs/:key` | 获取单个系统配置 | 是 |
| PUT | `/api/v1/system-configs/:key` | 更新系统配置 | 是 |

### 13.2 数据库表结构清单

#### 13.2.1 users表

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 13.2.2 proxy_services表

```sql
CREATE TABLE proxy_services (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    jump_host TEXT NOT NULL,
    jump_port INTEGER NOT NULL DEFAULT 22,
    jump_username TEXT NOT NULL,
    proxy_port INTEGER NOT NULL UNIQUE,
    ssh_key_path TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'stopped',
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 13.2.3 host_configs表

```sql
CREATE TABLE host_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    proxy_service_id INTEGER NOT NULL,
    hosts TEXT NOT NULL,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (proxy_service_id) REFERENCES proxy_services(id) ON DELETE CASCADE
);
```

#### 13.2.4 system_configs表

```sql
CREATE TABLE system_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT UNIQUE NOT NULL,
    value TEXT NOT NULL,
    description TEXT,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

#### 13.2.5 sessions表（由connect-sqlite3自动创建）

```sql
CREATE TABLE sessions (
    sid TEXT PRIMARY KEY,
    sess TEXT NOT NULL,
    expire INTEGER NOT NULL
);
```

### 13.3 配置文件示例

#### 13.3.1 package.json（后端）

```json
{
  "name": "socks-proxy-backend",
  "version": "1.0.0",
  "description": "Socks Proxy Backend",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "connect-sqlite3": "^0.9.13",
    "sqlite3": "^5.1.6",
    "bcryptjs": "^2.4.3",
    "ssh2": "^1.15.0",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  }
}
```

#### 13.3.2 package.json（前端）

```json
{
  "name": "socks-proxy-frontend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.3.4",
    "vue-router": "^4.2.5",
    "pinia": "^2.1.7",
    "element-plus": "^2.4.4",
    "axios": "^1.6.2",
    "highlight.js": "^11.9.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.5.0",
    "vite": "^5.0.8"
  }
}
```

#### 13.3.3 .env示例

```bash
# 代理服务配置
PROXY_HOST=192.168.1.4
PROXY_PORT=8090

# 应用配置
NODE_ENV=production
SESSION_SECRET=your-secret-key-change-this

# 数据库配置
DATABASE_PATH=/data/database.db

# 日志配置
LOG_LEVEL=info
```

#### 13.3.4 vite.config.js示例

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false
  }
})
```

### 13.4 常见问题

#### 13.4.1 部署相关问题

**Q: 容器启动后无法访问Web界面？**

A: 检查以下几点：
1. 端口映射是否正确：`-p 8090:8090`
2. 防火墙是否开放8090端口
3. 容器日志查看错误信息：`docker logs socks-proxy`
4. nginx配置是否正确

**Q: 代理服务创建失败，SSH连接失败？**

A: 检查以下几点：
1. 跳板服务器地址和端口是否正确
2. 用户名和密码是否正确
3. 网络是否可达跳板服务器
4. 跳板服务器SSH服务是否运行
5. 查看后端日志获取详细错误信息

**Q: 数据丢失，容器重启后配置不见了？**

A: 检查以下几点：
1. Volume挂载是否正确：`-v ./data:/data`
2. 数据目录权限是否正确
3. 数据库文件是否存在：`./data/database/database.db`

#### 13.4.2 功能相关问题

**Q: PAC配置不更新？**

A: 检查以下几点：
1. Host配置是否已保存
2. 代理服务状态是否为running
3. 查看后端日志确认PAC生成是否成功
4. 清除浏览器缓存后重试

**Q: 代理服务无法启动？**

A: 检查以下几点：
1. 代理端口是否被占用
2. SSH密钥文件是否存在
3. autossh是否已安装
4. 查看进程日志：`docker exec socks-proxy ps aux | grep autossh`

**Q: Host配置冲突检测不准确？**

A: 确保：
1. 不同Host配置中的域名不重叠
2. 更新Host配置时正确传递`exclude_config_id`参数
3. 域名格式正确（不包含协议和路径）

#### 13.4.3 性能相关问题

**Q: 页面加载慢？**

A: 优化建议：
1. 启用nginx gzip压缩
2. 前端资源使用CDN（可选）
3. 减少API请求次数
4. 优化数据库查询

**Q: 代理服务响应慢？**

A: 检查：
1. 跳板服务器网络延迟
2. SSH连接质量
3. 代理服务负载情况
4. 考虑使用多个代理服务分流

#### 13.4.4 安全相关问题

**Q: 如何修改Session密钥？**

A: 设置环境变量：
```bash
export SESSION_SECRET=your-new-secret-key
```
或在docker run时：
```bash
-e SESSION_SECRET=your-new-secret-key
```

**Q: 如何启用HTTPS？**

A: 步骤：
1. 配置SSL证书
2. 修改nginx配置启用HTTPS
3. 更新前端API地址为HTTPS
4. 设置Cookie secure标志

#### 13.4.5 开发相关问题

**Q: 前端开发时如何连接后端API？**

A: 配置vite.config.js的proxy：
```javascript
server: {
  proxy: {
    '/api': {
      target: 'http://localhost:3000',
      changeOrigin: true
    }
  }
}
```

**Q: 如何调试代理服务问题？**

A: 方法：
1. 查看容器日志：`docker logs socks-proxy`
2. 进入容器调试：`docker exec -it socks-proxy sh`
3. 查看autossh进程：`ps aux | grep autossh`
4. 测试SSH连接：`ssh -i /data/ssh-keys/proxy-service-1 user@host`

### 13.5 参考资源

#### 13.5.1 官方文档

- [Vue 3 文档](https://vuejs.org/)
- [Element Plus 文档](https://element-plus.org/)
- [Express.js 文档](https://expressjs.com/)
- [SQLite 文档](https://www.sqlite.org/docs.html)
- [Docker 文档](https://docs.docker.com/)
- [Nginx 文档](https://nginx.org/en/docs/)

#### 13.5.2 相关工具

- [autossh](https://www.harding.motd.ca/autossh/)
- [ssh2 (Node.js)](https://github.com/mscdex/ssh2)
- [sqlite3 (Node.js)](https://github.com/TryGhost/node-sqlite3)

#### 13.5.3 设计参考

- [Material Design](https://material.io/design)
- [Google AI Studio](https://aistudio.google.com/)

---

**文档版本**：1.0  
**创建日期**：2024年  
**最后更新**：2024年

---

**文档版本**：1.0  
**创建日期**：2024年  
**最后更新**：待更新

